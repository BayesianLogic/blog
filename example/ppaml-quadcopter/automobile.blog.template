{# This is the jinja2 template for generating our model. #}

/*
Model for the no-noise version of the automobile problem.

At each time step, we have:
- state: x, y, theta, xdot, ydot, thetadot
  (the GPS location and orientation, and the translational and rotational
  velocities)
- observations: laser (361 readings)
- controls: velocity, steering

Notes:
- We ignore the intensity observations, for now.
- We assume the obstacles are fixed and at a known location, for now.

The state is always hidden. The lasers are observed only in some time steps,
because of time discretization.
*/


/*
 * Dynamics model.
 * We assume H = 0 so the velocity is measured at the center of the back axle.
 */

fixed Real param_a = {{ model.param_a }};
fixed Real param_b = {{ model.param_b }};
fixed Real param_h = {{ model.param_h }};
fixed Real param_L = {{ model.param_L }};

fixed Real xdot_sigma = {{ model.xdot_sigma }};
fixed Real ydot_sigma = {{ model.ydot_sigma }};
fixed Real thetadot_sigma = {{ model.thetadot_sigma }};

random Real new_xdot(Real theta, Real vel, Real steer) {
    = vel * cos(theta) - tan(steer) * (vel / param_L) * (
        (param_a * sin(theta) + param_b * cos(theta)))
};

random Real state_xdot(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_xdot(state_theta(timestep - 1), velocity(timestep), steering(timestep)),
        xdot_sigma)
};

random Real new_ydot(Real theta, Real vel, Real steer) {
    = vel * sin(theta) - tan(steer) * (vel / param_L) * (
        (param_a * cos(theta) + param_b * sin(theta)))
};

random Real state_ydot(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_ydot(state_theta(timestep - 1), velocity(timestep), steering(timestep)),
        ydot_sigma)
};

random Real new_thetadot(Real vel, Real steer) {
    = tan(steer) * (vel / param_L)
};

random Real state_thetadot(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_thetadot(velocity(timestep), steering(timestep)),
        thetadot_sigma)
};

random Real state_x(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)
    else ~ UnivarGaussian(0, 1)
};

random Real state_y(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)
    else ~ UnivarGaussian(0, 1)
};

random Real state_theta(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)
    else ~ UnivarGaussian(0, 1)
};


/*
 * Observation model.
 * FIXME pick a more reasonable prior?
 */

fixed Real[] lasers_mu = {{ model.lasers_mu |blog_column_vector }};

fixed Real[][] lasers_sigma = {{ model.lasers_sigma |blog_matrix }};

random Real[] lasers_func(Real x, Real y, Real theta) {
    // FIXME placeholder
    ~ MultivarGaussian(lasers_mu, lasers_sigma)
};

random Real[] lasers(Integer timestep) {
    = lasers_func(state_x(timestep), state_y(timestep), state_theta(timestep))
};


/*
 * The controls are fixed values.
 * Using "random" instead of "fixed" because of bug in BLOG.
 */

random Real velocity(Integer timestep) {
    if false then = 0
    {%- for timestep in range(last_timestep + 1) %}
    else if timestep == {{ timestep }} then = {{ controls[timestep].velocity }}
    {%- endfor %}
};

random Real steering(Integer timestep) {
    if false then = 0
    {%- for timestep in range(last_timestep + 1) %}
    else if timestep == {{ timestep }} then = {{ controls[timestep].steering }}
    {%- endfor %}
};


/* Observations: */

{% for obs in observations %}
obs lasers({{ obs.timestep }}) = {{ obs.laser|blog_column_vector }};
{%- endfor %}


/* Query the hidden state: */

{% for timestep in range(last_timestep + 1) %}
query state_x({{ timestep }});
query state_y({{ timestep }});
query state_theta({{ timestep }});
{%- endfor %}
