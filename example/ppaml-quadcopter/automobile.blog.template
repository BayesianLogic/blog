{# This is the jinja2 template for generating our model. #}

/*
Model for the no-noise version of the automobile problem.

At each time step, we have:
- state: x, y, theta, xdot, ydot, thetadot
  (the GPS location and orientation, and the translational and rotational
  velocities)
- observations: laser (361 readings)
- controls: velocity, steering

Notes:
- We ignore the intensity observations, for now.
- We assume the obstacles are fixed and at a known location, for now.

The state is always hidden. The lasers are observed only in some time steps,
because of time discretization.
*/


/*
 * Dynamics model.
 * We assume H = 0 so the velocity is measured at the center of the back axle.
 * We assume delta_t is the fixed step size.
 */

fixed Real param_a = {{ model.param_a }};
fixed Real param_b = {{ model.param_b }};
fixed Real param_h = {{ model.param_h }};
fixed Real param_L = {{ model.param_L }};
fixed Real delta_t = {{ model.delta_t }};
fixed Real xdot_sigma = {{ model.xdot_sigma }};
fixed Real ydot_sigma = {{ model.ydot_sigma }};
fixed Real thetadot_sigma = {{ model.thetadot_sigma }};
fixed Real x_sigma = {{ model.x_sigma }};
fixed Real y_sigma = {{ model.y_sigma }};
fixed Real theta_sigma = {{ model.theta_sigma }};

random Real new_xdot(Real theta, Real vel, Real steer) {
    = vel * cos(theta) - tan(steer) * (vel / param_L) * (
        (param_a * sin(theta) + param_b * cos(theta)))
};

random Real state_xdot(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_xdot(state_theta(timestep - 1), velocity(timestep), steering(timestep)),
        xdot_sigma)
};

random Real new_ydot(Real theta, Real vel, Real steer) {
    = vel * sin(theta) - tan(steer) * (vel / param_L) * (
        (param_a * cos(theta) + param_b * sin(theta)))
};

random Real state_ydot(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_ydot(state_theta(timestep - 1), velocity(timestep), steering(timestep)),
        ydot_sigma)
};

random Real new_thetadot(Real vel, Real steer) {
    = tan(steer) * (vel / param_L)
};

random Real state_thetadot(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_thetadot(velocity(timestep), steering(timestep)),
        thetadot_sigma)
};

random Real new_x(Real x, Real xdot) {
    = x + delta_t * xdot
};

random Real state_x(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_x(state_x(timestep - 1), state_xdot(timestep - 1)),
        x_sigma)
};

random Real new_y(Real y, Real ydot) {
    = y + delta_t * ydot
};

random Real state_y(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_y(state_y(timestep - 1), state_ydot(timestep - 1)),
        y_sigma)
};

random Real new_theta(Real theta, Real thetadot) {
    = theta + delta_t * thetadot
};

random Real state_theta(Integer timestep) {
    if timestep == 0 then ~ UnivarGaussian(0, 1)  /* TODO prior */
    else ~ UnivarGaussian(
        new_theta(state_theta(timestep - 1), state_thetadot(timestep - 1)),
        theta_sigma)
};


/*
 * Observation model.
 * For now, we assume a single obstacle with known location and radius.
 * The code here is hard to follow because we only have matrix operations and
 * function application. For a more readable imperative version, see laser.py.
 *
 * FIXME: Deterministic functions defined as random because of bug in BLOG...
 */

fixed Real obstacle_x = {{ model.obstacle_x }};
fixed Real obstacle_y = {{ model.obstacle_y }};
fixed Real obstacle_r = {{ model.obstacle_r }};

fixed Real[] laser_angles = {{ model.laser_angles |blog_column_vector }};

fixed Real laser_eqn_a = 1.0;
random Real[] laser_eqn_bs(Real laser_x, Real laser_y, Real laser_theta) {
    = (2 * (laser_x - obstacle_x) * cos(laser_theta + laser_angles) +
       2 * (laser_y - obstacle_y) * sin(laser_theta + laser_angles))
};
random Real[] laser_eqn_cs(Real laser_x, Real laser_y) {
    = ((laser_x - obstacle_x) ^2 +
       (laser_y - obstacle_y) ^2 -
       obstacle_r ^2)
};
random Real[] laser_eqn_deltas(Real laser_x, Real laser_y, Real laser_theta) {
    = (laser_eqn_bs(laser_x, laser_y, laser_theta) ^2
       - 4.0 * laser_eqn_a * laser_eqn_cs(laser_x, laser_y))
};
/*
random Real[] laser_no_soln_indicators(Real laser_x, Real laser_y, Real laser_theta) {
    // LEFT TODO: need indicator function
};
*/




fixed Real[] lasers_mu = {{ model.lasers_mu |blog_column_vector }};

fixed Real[][] lasers_sigma = {{ model.lasers_sigma |blog_matrix }};

random Real[] lasers_func(Real x, Real y, Real theta) {
    // FIXME placeholder
    ~ MultivarGaussian(lasers_mu, lasers_sigma)
};

random Real[] lasers(Integer timestep) {
    = lasers_func(state_x(timestep), state_y(timestep), state_theta(timestep))
};


/*
 * The controls are fixed values.
 * Using "random" instead of "fixed" because of bug in BLOG.
 */

random Real velocity(Integer timestep) {
    if false then = 0
    {%- for timestep in range(last_timestep + 1) %}
    else if timestep == {{ timestep }} then = {{ controls[timestep].velocity }}
    {%- endfor %}
};

random Real steering(Integer timestep) {
    if false then = 0
    {%- for timestep in range(last_timestep + 1) %}
    else if timestep == {{ timestep }} then = {{ controls[timestep].steering }}
    {%- endfor %}
};


/* Observations: */

{% for obs in observations %}
obs lasers({{ obs.timestep }}) = {{ obs.laser|blog_column_vector }};
{%- endfor %}


/* Query the hidden state: */

{% for timestep in range(last_timestep + 1) %}
query state_x({{ timestep }});
query state_y({{ timestep }});
query state_theta({{ timestep }});
{%- endfor %}
