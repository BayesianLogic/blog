
/** Possible worlds simulate plays of Monopoly. 
 ** See monopoly.eblog for possible observations and queries. **
 ** author siddharth srivastava, xiang cheng**/


nonrandom Integer NumSquares = 40; // Number of properties on the board
nonrandom Timestep MaxTime = @500; // Number of timesteps for which to simulate
decision Boolean chosen_Buy(Timestep t);
decision Boolean donothing(Timestep t);

random Boolean observable(applied_payRent(Integer p1, Integer p2, Timestep t)){
  if (true) then
    = true
};

random Real lastPlayerStrat ~ Categorical({0.3->0.5, 0.7->0.5});
nonrandom Real otherPlayersStrat = 1;
type Color;
distinct Color c0, c1, c2, c3, c4, c5, c6, c7, c8;

//random Integer numPlayers  ~ UniformInt(6,12); 
nonrandom Integer numPlayers = 2;
//nonrandom Integer numPlayers = 12;

random Color propertyColor(Integer n){
	if (n == 1 | n==3) then = c1
	else if (n == 6  | n == 8  | n == 9)  then = c2
	else if (n == 11 | n == 13 | n == 14) then = c3
	else if (n == 16 | n == 18 | n == 19) then = c4
	else if (n == 21 | n == 23 | n == 24) then = c5
	else if (n == 26 | n == 27 | n == 29) then = c6
	else if (n == 31 | n == 32 | n == 34) then = c7
	else if (n == 37 | n == 39) then = c8
	else  = c0
};

random Boolean ownsAllOfColor(Integer p, Color c, Timestep t){
       if ((c == c1 & 
       	       	  propertyOwner(1, t) == p & propertyOwner(3, t) == p ) |
	  (c == c2 & 
       	       	  propertyOwner(6, t) == p & propertyOwner(8, t) == p & propertyOwner(9, t) == p) |
          (c == c3 & 
       	       	  propertyOwner(11, t) == p & propertyOwner(13, t) == p & propertyOwner(14, t) == p) |
 	  (c == c4 & 
       	       	  propertyOwner(16, t) == p & propertyOwner(18, t) == p & propertyOwner(19, t) == p) |
 	  (c == c5 & 
       	       	  propertyOwner(21, t) == p & propertyOwner(23, t) == p & propertyOwner(24, t) == p) |
 	  (c == c6 & 
       	       	  propertyOwner(26, t) == p & propertyOwner(27, t) == p & propertyOwner(29, t) == p) |
 	  (c == c7 & 
       	       	  propertyOwner(31, t) == p & propertyOwner(32, t) == p & propertyOwner(34, t) == p) |
 	  (c == c8 & 
       	       	  propertyOwner(37, t) == p & propertyOwner(39, t) == p) )
		  then = true
		  else = false
};



random Boolean applied_move(Integer p, Timestep t){
//Must move if dice was thrown at the previous timestep
       if (t == @0) then 
         = false 
       else if ((whosTurn(t) == p) & applied_throwDice(p, Prev(t))) then 
         = true
       else 
         = false
};

random Boolean applied_throwDice(Integer p, Timestep t){
//Must throw dice if not thrown yet in this turn and it is player p's turn
	if (t==@0) then 
	  = false
	else if exists_Timestep_throwDice(p, Prev(t)) then 
	  = false
	else if (! (whosTurn(t) == p)) then 
	  = false
	else 
	  = true
};

random Boolean exists_Timestep_throwDice(Integer p, Timestep t){
  if (t == @0) then
    = false
  else if (applied_advanceTurn(t)) then
    = false
  else
    = exists_Timestep_throwDice(p, Prev(t)) | applied_throwDice(p, t)
};


random Boolean applied_advanceTurn(Timestep t){
//Must advance turn if all obligations are done
	if (t == @0) then 
	  = true
	else if obligationsDone(t) then 
	  = true
	else 
	  = false
};

//precons for axn application at t need to talk about conditions at t itself
random Boolean applied_purchase(Integer player, Integer propertyNum, Timestep t){
//If on an unowned property of color other than 0, can purchase it
  if (obligationsDone(t) & playerAt(player, t) == propertyNum & (whosTurn(t) == player) & 
      propertyOwner(propertyNum, t) == numPlayers & (propertyColor(propertyNum) != c0 )) then
      if (player == (numPlayers - 1) ) then
        ~ Bernoulli(lastPlayerStrat)
      else 
        = chosen_Buy(t)
  else 
  	   = false
};




random Boolean applied_payRent(Integer p, Integer owner, Timestep t){
//Must pay rent if it is due and there is sufficient capital
    if (t == @0) then 
      = false
	  else if (rentDue(p, owner, t) < capital(p, t) 
	  	 & rentDue(p, owner, t)>0) then 
	    = true
	  else 
	    = false
};

random Integer amtRentPaid (Integer p, Integer owner, Timestep t){
  if (applied_payRent(p,owner,t)) then
    = rentDue (p, owner, t)
  else
    = 0
    
};

random Integer playerAt(Integer p, Timestep t){
//player p's position at timestep t
	     if (t == @0) then 
	       = 0
	     else if (p == whosTurn(Prev(t)) & applied_move(p, Prev(t))) then 
	       = (playerAt(p, Prev(t)) + diceVal1(Prev(t)) + diceVal2(Prev(t)))%  NumSquares
	     else 
	       = playerAt(p, Prev(t))
};

random Integer AddModNWrapper(Integer position, Integer d1, Integer d2, Integer NumSq) {
  if ( (position + d1 + d2) < NumSq) then
    = 1 + 2 % 5
  else
    = AddModNWrapper (position + d1 + d2 - NumSq, 0, 0, NumSq)
};

random Integer diceVal1(Timestep t) {
//Value of the dice1. Set to a new value if throwDice occured at previous timestep.
 	    if (t==@0) then 
 	      = 0
 	    else if exists Integer p (p < numPlayers & p == whosTurn(Prev(t)) 
	    	   & applied_throwDice(p, Prev(t))) then 
	    	~ UniformInt(1,6)
 	    else = diceVal1(Prev(t))
};
random Integer diceVal2(Timestep t) {
//Similar to diceVal1
 	    if (t==@0) then 
 	      = 0
 	    else if exists Integer p (p < numPlayers & p == whosTurn(Prev(t)) & 
	    	   applied_throwDice(p, Prev(t))) then 
        ~ UniformInt(1,6)
 	    else 
 	      = diceVal2(Prev(t))
};
random Integer whosTurn(Timestep t){
//Gets the player who's turn this is.
//Implements +1 mod NumPlayers
	if (t == @0) then 
	  = 0
	else if (t == @1) then 
	  = 0
	else if (applied_advanceTurn(Prev(t)) & (whosTurn(Prev(t)) == (numPlayers - 1))) then 
	  = 0
	else if applied_advanceTurn(Prev(t)) then 
	  = Succ(whosTurn(Prev(t)))
	else 
	  = whosTurn(Prev(t))
};
random Boolean obligationsDone(Timestep t) {
//In every turn, throwing dice and moving according to them must take place.
//If a player lands on another's property, rentDues must be made 0.
//Turn is allowed to change only if all these obligations are done.
		   if (t == @0) then 
		     = false
		   else if (applied_advanceTurn(Prev(t))) then 
		     = false
		   else if exists_Timestep_obligationsDone_1(whosTurn(t), Prev(t)) &
		     exists_Timestep_obligationsDone_2(whosTurn(t), Prev(t))
		     then 
		     = forall Integer owner (( (owner < numPlayers) & (owner!= whosTurn(t))) => (rentDue(whosTurn(t),owner,t) == 0)) //??? see above
};

random Boolean exists_Timestep_obligationsDone_1(Integer p, Timestep t){
  if (t == @0) then
    = false
  else if (applied_advanceTurn(t)) then
    = false
  else
    = exists_Timestep_obligationsDone_1(p, Prev(t)) | applied_throwDice(p,t)
};

random Boolean exists_Timestep_obligationsDone_2(Integer p, Timestep t){
  if (t == @0) then
    = false
  else if (applied_advanceTurn(t)) then
    = false
  else
    = exists_Timestep_obligationsDone_2(p, Prev(t)) | applied_move(p,t)
};

random Timestep timeOfLastTurnAdvance(Timestep t) {
//Gets the timestep at which this turn started.
//Used to determine if the required actions for the turn have been executed, rent has been paid etc.
  if (t == @0) then 
    = @0
	else if applied_advanceTurn(Prev(t)) then 
	  = Prev(t)
	else 
	  = timeOfLastTurnAdvance(Prev(t))
};

random Integer capital(Integer player, Timestep t){
    
		if (t == @0) then 
		  = 500
		else if exists Integer prop prop<NumSquares & applied_purchase(player, prop, Prev(t)) then 
		  = capital(player, Prev(t)) - propertyValue(playerAt(player, Prev(t)))
	  else if exists Integer buyer buyer <numPlayers & exists Integer prop prop<NumSquares & applied_purchase(buyer, prop, Prev(t)) & propertyOwner(playerAt(buyer, Prev(t)), Prev(t))==player then 
		  = capital(player, Prev(t)) + propertyValue(propertyBuyerFor(player, t))
		else if exists Integer renter (renter < numPlayers & applied_payRent(renter, player, Prev(t))) then 
		  = capital(player, Prev(t)) + rentDue(rentPayerFor(player, t), player, Prev(t))
		else if exists Integer owner (owner < numPlayers & applied_payRent(player, owner, Prev(t))) then 
		  = capital(player, Prev(t)) - rentDue(player, rentOwnerFor(player,t), Prev(t))
		else 
		  = capital(player, Prev(t))
};

random Integer rentOwnerFor(Integer player, Timestep t) 
  ~ Iota({Integer owner : owner < numPlayers & applied_payRent(player, owner, Prev(t))});

random Integer propertyBuyerFor(Integer player, Timestep t) 
  ~ Iota({Integer buyer : buyer <numPlayers & exists Integer prop prop<NumSquares & applied_purchase(buyer, prop, Prev(t)) & propertyOwner(playerAt(buyer, Prev(t)), Prev(t))==player });

random Integer propertyOwner(Integer propertyNum, Timestep t){
//Set to NumPlayers (meaning not owned by any player) by default
//Changed by purchase action. Auctioning of property not modeled.
		  if (t==@0) then 
		    = numPlayers
		  else if (exists Integer p (p < numPlayers) & whosTurn(Prev(t)) == p & applied_purchase(p, propertyNum, Prev(t))) then 
		    ~ Iota({Integer p: (p < numPlayers) & whosTurn(Prev(t)) == p & applied_purchase(p, propertyNum, Prev(t))})
		  else 
		    = propertyOwner(propertyNum, Prev(t))
};



random Integer rentDue(Integer currentPlayer, Integer owner, Timestep t){
//Rent is not due if t=0 or if already paid this turn. It is equal to the property value if
//not already paid. 
		if (t==@0) | propertyColor((playerAt(currentPlayer, Prev(t))))==c0 then 
		  = 0
		else if (applied_payRent(currentPlayer, owner, Prev(t))) then 
		  = 0
		else if exists_Timestep_rentPaid(currentPlayer, owner, Prev(t)) then
		  = 0		
		else if ( (whosTurn(t) == currentPlayer) & 
		          (propertyOwner(playerAt(currentPlayer, Prev(t)), Prev(t)) == owner) & 
		          (owner!=currentPlayer) & owner != numPlayers) then
		  = propertyRent(playerAt(currentPlayer, Prev(t)), Prev(t))
		else
		  = rentDue(currentPlayer, owner, Prev(t))
};

random Boolean exists_Timestep_rentPaid(Integer currentPlayer, Integer owner, Timestep t){
  if (t == @0) then
    = false
  else if (applied_advanceTurn(t)) then
    = false
  else
    = exists_Timestep_rentPaid(currentPlayer, owner, Prev(t)) | applied_payRent(currentPlayer, owner, t)
};

//Use Iota function to extract rent. Needed to determine capital of a player if 
//another player paid it rent. (See capital(player, t))
random Integer rentPayerFor(Integer player, Timestep t) 
  ~ Iota({Integer renter : ( renter < numPlayers & applied_payRent(renter, player, Prev(t)) ) });



//Replace with another property value function
random Integer propertyValue(Integer sq){
  if (true) then
    = 2
  else
    = -1 //??? hacky way to get around blog idiosyncracy
};

random Integer propertyRent(Integer sq, Timestep t){
  if ownsAllOfColor(propertyOwner(sq, t), propertyColor(sq), t)
     then = 10
  else = 5
};

random Integer numberRentsObtained(Integer player, Timestep t){
	if (t == @0) then 
	  = 0
	else if (exists Integer renter (renter < numPlayers & applied_payRent(renter, player, Prev(t)))) then 
	  = Succ(numberRentsObtained(player, Prev(t)))
	else 
	  = numberRentsObtained(player, Prev(t))
};



//------------------------Query---------------------------

//obs LessThan(capital(1, MaxTime), 450) = true;

//obs GreaterThan(numberRentsPaid(0, MaxTime), 7) = true;
//obs GreaterThan(numberRentsObtained(0, MaxTime), 25) = true;

//query axnsUntil(MaxTime);
//query capital(0,MaxTime);
//query capital(1,MaxTime);
//query capital(2,MaxTime);

//query playerAt(0,MaxTime);
//query playerAt(1,MaxTime);
//query playerAt(2,MaxTime);
query numPlayers;


// Query to test if player 2 paid rent at any time in the game
//query exists NaturalNum t exists NaturalNum o (o< numPlayers & t<MaxTime & o>=0 & applied_payRent(2,o,t));
//Doesn't work. (Loop on o & t)

query exists Timestep t (t<MaxTime & (exists Integer o o < numPlayers & o>=0 & applied_payRent(1,o,t)));

query numberRentsObtained(1,MaxTime);
//query NumPlayers2;



query #{Integer pro : pro < NumSquares & propertyOwner(pro, MaxTime) == 0};
query #{Integer pro : pro < NumSquares & propertyOwner(pro, MaxTime) == 1};
query #{Integer pro : pro < NumSquares & propertyOwner(pro, MaxTime) == 2};
query playerAt(0,MaxTime);
query capital(0,MaxTime);
query capital(1,MaxTime);
query capital(2,MaxTime);
//query {Integer p: ((p<NumPlayers) & (whosTurn(Prev(@3)) == p) & applied_purchase(p, 1, Prev(@3)) )};
obs numberRentsObtained(1, MaxTime) = 1;
query lastPlayerStrat;
query 1 + 5 % 3;


//query {Integer i : i< 10};





