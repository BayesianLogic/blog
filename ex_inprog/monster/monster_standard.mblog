Integer MaxDoor = 15;
#Monster ~ Poisson(6);

generating Monster Source(Sound);
generating Timestep Sound_Time(Sound);

random Integer DoorOf(Monster m, Timestep t) {
   if t == @0 then ~ UniformChoice({Integer n: n< Max & n>=0})
   else ~ Categorical([SuccMod(DoorOf(m, t-1), MaxDoor) -> 0.3,
                                 PredMod(DoorOf(m, t-1), MaxDoor) -> 0.3,
                                 DoorOf(m, t-1) -> 0.4])
};		

#Sound(Source = m, Sound_Time = t) ~ {if apply_listen(t-1) then ~Bernoulli(0.5)
                                        else = 0};

random Door ApparentDoor(Sound s) ~
           Categorical([SuccMod(DoorOf(Src(Sound)), MaxDoor) -> 0.15, 
                          DoorOf(Src(Sound))     -> 0.70, 
                          PredMod(DoorOf(Src(Sound)), MaxDoor)-> 0.15]);

random Integer reward(Timestep t) {
    if apply_listen(t) then = -1
    else if exists Door d d< MaxDoor apply_enter(Door d, t) & exists Monster m
      DoorOf(m, t) == d then = -100
    else if exists Door d  d<MaxDoor apply_enter(Door d, t) & !(exists Monster m
      DoorOf(m, t) == d ) then = 10
};

observable(Sound);
observable(ApparentDoor(s));

decision apply_enter(Door d, Timestep t);
decision apply_listen(Timestep t);

/*helpers for policy*/
SoundAroundDoor(Door d, t) = (exists Sound s Sound_Time(s)==t & (
         ApparentDoor(s, t) == SuccMod(d, MaxDoor) |
         ApparentDoor(s, t) == d |
         ApparentDoor(s, t) == PredMod(d, MaxDoor));
MonsterAtDoor(d, t) = (exists Monster m DoorOf(m, t) == d)
MonsterAroundDoor(d, t) = (MonsterAtDoor(PredMod(d, MaxDoor)) | 
                                             MonsterAtDoor(d) | 
                                             MonsterAtDoor(SuccMod(d, MaxDoor)))
