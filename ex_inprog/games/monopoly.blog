/** Possible worlds simulate plays of Monopoly. 
 ** See monopoly.eblog for possible observations and queries. **
 ** author siddharth srivastava 
    modified by Bharath Ramsundar
 **/

// Number of properties on the board
fixed Integer NumSquares = 40; 
// Number of timesteps for which to simulate
fixed Timestep MaxTime = @250; 
//Replace with another property value function
fixed Integer propertyValue(Integer sq) = 5;
fixed Integer propertyRent(Integer sq) = 5;

random Integer NumPlayers ~ Poisson(6);
          
//Must move if dice was thrown at the previous timestep
random Boolean applied_move(Integer p, Timestep t) {
  if t == @0 then = false 
  else if whosTurn(t) == p & applied_throwDice(p, prev(t)) then = true
  else = false
};

//Must throw dice if not thrown yet in this turn and it is player p's turn
random Boolean applied_throwDice(Integer p, Timestep t) {
  if t == @0 then = false
  else if exists Timestep tstep ((timeOfLastTurnAdvance(t) < tstep) & 
          (tstep < t) & applied_throwDice(p,tstep)) then = false
  else if !(whosTurn(t) == p) 
      then = false
  else = true
};

//Must advance turn if all obligations are done
random Boolean applied_advanceTurn(Timestep t) {
	if t == @0 then = true
	else if obligationsDone(t) then = true
	else = false
};

//  precons for axn application at t need to talk about conditions at t itself
//  If on an unowned property, can purchase it
random Boolean applied_purchase(Integer player, Integer propertyNum, Timestep t) {
  if obligationsDone(t) & playerAt(player, t) == propertyNum & 
     whosTurn(t) == player & 
	   propertyOwner(propertyNum, t) == NumPlayers 
     then ~ Bernoulli(0.5)
	      //This is 50% likely over all rand generations, not for this player alone
   else = false
};
  
//  Must pay rent if it is due and there is sufficient capital
random Boolean applied_payRent(Integer p, Integer owner, Timestep t) {
  if t == @0 then = false
  else if rentDue(p, owner, t) < capital(p, t) 
  	 & rentDue(p, owner, t) > 0
  	 then = true
  else = false
};


//  An action is applied if either of throwDice, advanceTurn, move, payRent,
//  purchase take place
random Boolean axnApplied(Timestep t) {
  = (exists Integer p (p < NumPlayers) & 
      (exists Integer o (o < NumPlayers) & 
        (applied_throwDice(p, t) | applied_move(p, t) | applied_advanceTurn(t) | 
         applied_purchase(p, playerAt(p, t), t) | applied_payRent(p, o, t)))) 
};

random Boolean axnsUntil(Timestep t) {
  //= forall Integer n (n < t -> axnApplied(n))
  = forall Timestep s (s < t) & axnApplied(s)
};

//player p's position at timestep t
random Integer playerAt(Integer p, Timestep t) {
  if t == @0 then = 0
  else if p == whosTurn(prev(t)) & applied_move(p,prev(t)) 
    then = (playerAt(p, prev(t)) + diceVal1(prev(t)) +  diceVal2(prev(t))) % NumSquares 
    else = playerAt(p, prev(t))
};

//Value of the dice1. Set to a new value if throwDice occured at previous timestep.
random Integer diceVal1(Timestep t) { 
  if t == @0 then = 0
  else if exists Integer p (p < NumPlayers & p == whosTurn(prev(t)) 
       & applied_throwDice(p, prev(t))) 
    then ~ UniformInt(1,6)
  else = diceVal1(prev(t))
};

//Similar to diceVal1
random Integer diceVal2(Timestep t) {
  if t == @0 then = 0
  else if exists Integer p (p < NumPlayers & p == whosTurn(prev(t)) & 
           applied_throwDice(p, prev(t))) 
    then ~ UniformInt(1, 6)
  else = diceVal2(prev(t))
};

//Gets the player who's turn this is.
//Implements +1 mod NumPlayers
random Integer whosTurn(Timestep t) {
	if t == @0 then = 0
	else if t == @1 then = 0
	else if applied_advanceTurn(prev(t)) & (whosTurn(prev(t)) == pred(NumPlayers)) 
    then = 0
	else if applied_advanceTurn(prev(t)) 
    then = succ(whosTurn(prev(t)))
	else = whosTurn(prev(t))
};

//In every turn, throwing dice and moving according to them must take place.
//If a player lands on another's property, rentDues must be made 0.
//Turn is allowed to change only if all these obligations are done.
random Boolean obligationsDone(Timestep t) {
  if t == @0 then = false
  else if applied_advanceTurn(prev(t)) 
    then = false
  else if exists Timestep tstep (timeOfLastTurnAdvance(t) < tstep) &
          (tstep < t) & (exists Integer p p < NumPlayers & whosTurn(t) == p &
          applied_throwDice(p,tstep)) &
          exists Timestep tstep (timeOfLastTurnAdvance(t) < tstep) & (tstep < t) &
          (exists Integer p p < NumPlayers & whosTurn(t) == p & 
          applied_move(p,tstep)) 
    then = 
      //forall Integer p ((p < NumPlayers & whosTurn(t) == p) ->
      //  (forall Integer owner (owner < NumPlayers & owner != p) -> 
      //    (rentDue(p,owner,t) == 0)))
      forall Integer p ((p < NumPlayers & whosTurn(t) == p) & 
        (forall Integer owner (owner < NumPlayers & owner != p) & 
          (rentDue(p,owner,t) == 0)))
};

//Gets the timestep at which this turn started. Used to determine if the
//required actions for the turn have been executed, rent has been paid etc.
random Timestep timeOfLastTurnAdvance(Timestep t) {
  if t == @0 then = @0
  else if applied_advanceTurn(prev(t)) then = prev(t)
  else = timeOfLastTurnAdvance(prev(t))
};

random Integer capital(Integer player, Timestep t) {
  if t == @0 then = 500
  else if exists Integer prop (prop < NumSquares) & 
          applied_purchase(player, prop, prev(t)) 
    then = capital(player, prev(t)) - propertyValue(playerAt(player, prev(t)))
  else if exists Integer renter (renter<NumPlayers & 
                                 applied_payRent(renter, player, prev(t)))
    then = capital(player, prev(t)) + rentDue(rentPayerFor(player, prev(t)), player, prev(t))
  //Need to use rentPayerFor(..) because existentially bound variables under the
  //"if... " do not retain their bindings for the "then..."
  // else if exists Integer owner (owner<NumPlayers & rentDue(player, owner, prev(t)) 
  //        & applied_payRent(player, prev(t)) )
  //        	 then = capital(player, prev(t)) - rentDue(player, owner, prev(t))
  // doesn't work because scope doesn't extend beyond "if.."
  else if exists Integer owner (owner < NumPlayers) & 
          applied_payRent(player, owner, prev(t))
    then = capital(player, prev(t)) - propertyRent(playerAt(player, prev(t)))
  else = capital(player, prev(t))
};

//Set to NumPlayers (meaning not owned by any player) by default
//Changed by purchase action. Auctioning of property not modeled.
random Integer propertyOwner(Integer propertyNum, Timestep t) {
  if t == @0 then = NumPlayers
  else if (exists Integer p (p < NumPlayers) & whosTurn(prev(t)) == p &
           applied_purchase(p, propertyNum, prev(t))) 
    then ~ Iota({Integer p: p < NumPlayers & whosTurn(prev(t)) == p & applied_purchase(p, propertyNum, prev(t))})
  else = propertyOwner(propertyNum, prev(t))
};

//Rent is not due if t=0 or if already paid this turn. It is equal to the
//property value if not already paid. 
random Integer rentDue(Integer currentPlayer, Integer owner, Timestep t) {
  if t == @0 then = 0
  else if applied_payRent(currentPlayer, owner, prev(t)) then = 0
  else if exists Timestep tstep (timeOfLastTurnAdvance(t) < tstep) &
          (tstep < t) & applied_payRent(currentPlayer, owner, tstep) then = 0		
  else if whosTurn(t) == currentPlayer & 
          propertyOwner(playerAt(currentPlayer, prev(t)), prev(t)) == owner & 
          owner != currentPlayer 
    then = propertyRent(playerAt(currentPlayer, prev(t))) else = rentDue(currentPlayer, owner, prev(t)) };

//Use Iota function to extract rent. Needed to determine capital of a player if 
//another player paid it rent. (See capital(player, t))
random Integer rentPayerFor(Integer player, Timestep t) {
  ~ Iota({Integer renter: renter < NumPlayers & applied_payRent(renter, player, t)})
};

random Integer numberRentsPaid(Integer player, Timestep t) {
	if t == @0 then = 0
	else if exists Integer owner (owner < NumPlayers & 
                                applied_payRent(player, owner, prev(t))) 
    then = succ(numberRentsPaid(player, prev(t)))
	else = numberRentsPaid(player, prev(t))
};

random Integer numberRentsObtained(Integer player, Timestep t) {
	if t == @0 then = 0
	else if exists Integer renter (renter < NumPlayers & 
      applied_payRent(renter, player, prev(t))) 
    then = succ(numberRentsObtained(player, prev(t)))
	else = numberRentsObtained(player, prev(t))
};

//obs LessThan(capital(1, MaxTime), 450) = true;

//obs GreaterThan(numberRentsPaid(0, MaxTime), 2) = true;
//obs GreaterThan(numberRentsObtained(0, MaxTime), 1) = true;
obs (numberRentsPaid(0, MaxTime) > 2) = true;
obs (numberRentsObtained(0, MaxTime) > 1) = true;

query axnsUntil(MaxTime);
query capital(0, MaxTime);
query capital(1, MaxTime);
query capital(2, MaxTime);

query playerAt(0,MaxTime);
query playerAt(1,MaxTime);
query playerAt(2,MaxTime);
query NumPlayers;


// Query to test if player 2 paid rent at any time in the game
//query exists Timestep t exists Integer o (t<MaxTime & o<NumPlayers & applied_payRent(2,o,t));
//Doesn't work. (Loop on o & t)

//query exists Timestep t (t < MaxTime) & (exists Integer o (o < NumPlayers) & 
//                                                         applied_payRent(2,o,t));
