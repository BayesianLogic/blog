/*
 * BLOG model for tracking multiple objects moving about a grid
 * author: Siddharth Srivastava
 *
 * Builds on aircraft-wandering.mblog
 * Using Integer instead of Timestep to allow mathematical ops on time during 
 * value computation.
 */
nonrandom Integer theta = 5;
type Target;
type Blip;

#Target ~ Poisson(5);

nonrandom Integer GridDimX=15;
nonrandom Integer GridDimY=1;
nonrandom Timestep ScanningTimeLimit=@30;
nonrandom Real gamma=1.0;


random Integer Max = GridDimX * GridDimY;
generating Target Source(Blip);
generating Timestep Time(Blip);


/////////////////////////
//** Target movement **//
/////////////////////////


/* Region(x, y) = y*GridDimX + x */
random Integer Class(Target o, Integer t) {
	~UniformChoice({Integer n:n<5})
};

random Integer RegionOf(Target o, Timestep t) {
		if t == @0 then ~ UniformChoice({Integer n: n< Max & n>=1})
		else ~ CorrectNextPosDistributionWrap(GridDimX, GridDimY, RegionOf(o, Prev(t)))
};		

#Blip(Source = o, Time = t){
     if (t!= @0) & (exists Integer r (r < GridDimX & applied_scan(r, Prev(t)) & RegionOf(o,t)==r))
                       then ~ Categorical({0->0.15, 1->0.7, 2->0.15})
     else = 0
};


random Integer turnsToDecide(Timestep t){
	if (t == @0) then
		= 0
	else if (true & TheEnd(t)) then
		= turnsToDecide(Prev(t))
	else
		= turnsToDecide(Prev(t)) + 1
	
};



random Boolean observable(observation_blip(Timestep t)){
  if (TheEnd(t)==true) then = false
else = true
};

random Integer observation_blip(Timestep t){
  if true then
    ~ Cardinality({Blip b : Time(b) == t})
};

/////////////////////////
//** Value function **//
////////////////////////

random Integer numObjects ~ Cardinality({Target o: true== true});

random Boolean TheEnd(Timestep t){
	if (t == @0) then
		= false
	else if (apply_alarm(Prev(t)) | apply_no_alarm(Prev(t)) | t == ScanningTimeLimit) then
		= true
	else = TheEnd(Prev(t))
};


random Real reward(Timestep t){
  if (TheEnd(Prev(t)) == true) then = 0
	else if numObjects >theta & apply_alarm(Prev(t)) then = 10
	else if numObjects <=theta & apply_alarm(Prev(t)) then   = -100
	else if numObjects >theta & apply_no_alarm(Prev(t)) then = -100
	else if numObjects <=theta & apply_no_alarm(Prev(t)) then = 10
	else if no_op(Prev(t)) then = -6
	else = -6
};



random Real value(Timestep t) {
	if (t == @0) then 
		= 0
	else 
		= value(Prev(t)) + reward(Prev(t))
};

random Integer NumBlips(Timestep t){
	if (true) then 
	= #{Blip b: Time(b)==t}
};

random Boolean detected (Target o, Timestep t){
	if (t == @0) then
		= false
	else if exists Integer s (s < GridDimX & RegionOf(o, Prev(t))==s & applied_scan(s, Prev(t))) then
		= true
	else
		= detected (o, Prev(t))
};

random Boolean scannedLastRound (Timestep t){
	if true then 
		= exists Integer s s<GridDimX & applied_scan(s, Prev(t))
};

random Boolean regionIsSuitable(Integer s, Timestep t){
	if true then 
		= true & (regionIsSuitableHelper(s, t) > 1)
};
random Integer regionIsSuitableHelper(Integer s, Timestep t){
	~ Cardinality({Target o : RegionOf(o, t) == s & !detected(o, t)})
};
/////////////////////////
//** Scanning policy **//
/////////////////////////

//Sequential
random Integer toScan(Timestep t){
 	if t==@0 then 
		= 1
  	else if (true & ((toScan(Prev(t)) + 1) > GridDimX)) then
		= 1
	else 
		= toScan(Prev(t)) + 1
 };

random Boolean applied_scan(Integer r, Timestep t){
	if t<ScanningTimeLimit & r==toScan(t) then = true
	else = false
};



///////start of policy/////////////

nonrandom Integer cycleSize = 15;
nonrandom Integer freqSignificanceThreshold=2;

random Integer fTimeToInt (Timestep t) {
  if true then
    ~ TimeToInt(t)
};
random Timestep fIntToTime (Integer i) {
  if true then
    ~ IntToTime(i)
};

random Timestep cycleStart (Integer c) {if true then ~IntToTime(c * cycleSize)};




random Timestep cycleEnd (Integer c){
	if true then
		~IntToTime( ((c + 1) * cycleSize) - 1)
};

random Boolean currentCycle(Integer c, Timestep t){
	if true then
		= (fTimeToInt(cycleStart(c))<=fTimeToInt(t) & fTimeToInt(cycleEnd(c))>=fTimeToInt(t))
};

random Integer lastCycleInt(){
	if true then
		~ UniformChoice({Integer n : n <= 2 & currentCycle(n, ScanningTimeLimit)})
};

nonrandom Integer lastCycle= 2;

random Integer numBlipsPerCycle(Integer c){
	if true then
		~ Cardinality({Blip b: Time(b)<= cycleEnd(c) & Time(b) >= cycleStart(c)})
};

random Integer maxBlipsPerCycle(Integer c){
	if c==0 then 
		= numBlipsPerCycle(c)
	else if numBlipsPerCycle(c) > maxBlipsPerCycle(Pred(c)) then 
		= numBlipsPerCycle(c)
	else 
		= maxBlipsPerCycle(Pred(c))
};

random Integer maxEstimate = maxBlipsPerCycle(2);

random Integer minBlipsPerCycle(Integer c){
	if c==0 then 
		= numBlipsPerCycle(c)
	else if numBlipsPerCycle(c) < minBlipsPerCycle(Pred(c)) then 
		= numBlipsPerCycle(c)
	else 
		= minBlipsPerCycle(Pred(c))
};

random Integer minEstimate = minBlipsPerCycle(lastCycle);

random Integer countCyclesWithAtLeastKBlips (Integer k){
	if true then
		~ Cardinality({Integer c : c <= 2 & numBlipsPerCycle(c)>=k})
};

random Boolean HiBlipCountCrossesFreqThreshold(Integer k){
	if true then
		= (countCyclesWithAtLeastKBlips(k)>=freqSignificanceThreshold)
};

random Boolean maxBlipCountCrossingFreqThreshold(Integer k){
	if true then
		= HiBlipCountCrossesFreqThreshold(k) & 
			(forall Integer l (l <= maxBlipsPerCycle(lastCycle) & HiBlipCountCrossesFreqThreshold(l)) => l<=k)
};

random Integer sigMaxEstimate ~ UniformChoice ({Integer n : n <= maxBlipsPerCycle(lastCycle) & maxBlipCountCrossingFreqThreshold(n)});

random Integer countCyclesWithAtMostKBlips(Integer k){
	if true then 
		~ Cardinality({Integer c: c<=2 & numBlipsPerCycle(c)<=k})
};

random Boolean LoBlipCountCrossesFreqThreshold(Integer k){
	if true then
		= (countCyclesWithAtMostKBlips(k) >= freqSignificanceThreshold)
};

random Boolean minBlipCountCrossingFreqThreshold(Integer k){
	if true then 
		= LoBlipCountCrossesFreqThreshold(k) & (forall Integer l (l <= maxBlipsPerCycle(lastCycle) & LoBlipCountCrossesFreqThreshold(l)) => l >= k)
};

random Integer sigMinEstimate ~ UniformChoice({Integer n: n <= maxBlipsPerCycle(lastCycle) & minBlipCountCrossingFreqThreshold(n)});

random Integer reportedEstimate () { if true then =(sigMinEstimate + sigMaxEstimate)/2};


random Boolean apply_no_alarm(Timestep t){
	if (t!= ScanningTimeLimit) then
		= false
	else
		= reportedEstimate <= theta
};
random Boolean apply_alarm(Timestep t){
	if (t!= ScanningTimeLimit) then
		= false
	else
		= reportedEstimate >= theta
};
random Boolean no_op(Timestep t){
	if (t!= ScanningTimeLimit) then
		= true
	else
		= false
};

query value(@30);
