/*
 * BLOG model for tracking multiple objects moving about a grid
 * author: Siddharth Srivastava
 *
 * Builds on aircraft-wandering.mblog
 * Using Integer instead of Timestep to allow mathematical ops on time during 
 * value computation.
 */

type Target;
type Blip;

nonrandom Integer theta = 3;
#Target ~ Poisson(theta);

nonrandom Integer GridDimX=10;
nonrandom Integer GridDimY=1;
nonrandom Timestep ScanningTimeLimit=@30;
nonrandom Integer CycleSize=10;
nonrandom Real gamma=1.0;

random Integer Max = GridDimX * GridDimY;
generating Target Source(Blip);
generating Timestep Time(Blip);


/////////////////////////
//** Target movement **//
/////////////////////////


/* Region(x, y) = y*GridDimX + x */
random Integer Class(Target o, Integer t) {
	~UniformChoice({Integer n:n<5})
};

random Integer RegionOf(Target o, Timestep t) {
		if t == @0 then ~ UniformChoice({Integer n: n< Max})
		else ~ NextPosDistributionWrap(GridDimX, GridDimY, RegionOf(o, Prev(t)))
};		

#Blip(Source = o, Time = t){
     if (t!= @0) & (exists Integer r applied_scan(r, Prev(t)) & RegionOf(o,t)==r)
                       then ~ Categorical({0->0.15, 1->0.7, 2->0.15})
     else = 0
};

random Integer observation_blip(Timestep t){
  if true then
    ~ Cardinality({Blip b : Time(b) == t})
};

/////////////////////////
//** Value function **//
////////////////////////

random Integer numObjects ~ Cardinality({Target o: true== true});

random Boolean TheEnd(Timestep t){
	if (t == @0) then
		= false
	else if (apply_alarm(Prev(t)) | apply_no_alarm(Prev(t)) | t == ScanningTimeLimit) then
		= true
	else = TheEnd(Prev(t))
};

decision Boolean apply_no_alarm(Timestep t);
decision Boolean apply_alarm(Timestep t);
decision Boolean no_op(Timestep t);

random Real reward(Timestep t){
  if (TheEnd(Prev(t)) == true) then = 0
	else if numObjects >theta & apply_alarm(Prev(t)) then = 10
	else if numObjects <=theta & apply_alarm(Prev(t)) then   = -100
	else if numObjects >theta & apply_no_alarm(Prev(t)) then = -100
	else if numObjects <=theta & apply_no_alarm(Prev(t)) then = 10
	else if no_op(Prev(t)) then = -10
	else = 0
};



random Real value(Timestep t) {
	if (t == @0) then 
		= 0
	else 
		= value(Prev(t)) + reward(Prev(t))
};

random Integer NumBlips(Timestep t){
	if (true) then 
	= #{Blip b: Time(b)==t}
};

/////////////////////////
//** Scanning policy **//
/////////////////////////

//Random but not the last scanned region
random Integer toScan(Timestep t){
 	  if t==@0 then = 1
  	else if toScan(Prev(t)) == Max then = 1
	  else = toScan(Prev(t)) + 1
 };

random Boolean applied_scan(Integer r, Timestep t){
	if t<ScanningTimeLimit & r==toScan(t) then = true
	else = false
};

random Boolean observable(observation_blip(Timestep t)) = true;

//obs observation_blip(@5)=1;

//query numObjects;

//query reward(ScanningTimeLimit);
//query value(ScanningTimeLimit);



