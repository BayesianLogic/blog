/**
 * 
 */
package blog.sample;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import blog.ObjectIdentifier;
import blog.bn.BasicVar;
import blog.bn.BayesNetVar;
import blog.bn.NumberVar;
import blog.bn.OriginVar;
import blog.bn.VarWithDistrib;
import blog.common.HashMultiMap;
import blog.common.MultiMap;
import blog.distrib.CondProbDistrib;
import blog.model.ArgSpec;
import blog.model.DependencyModel;
import blog.model.NonGuaranteedObject;
import blog.world.PartialWorld;

/**
 * A Evaluation Context class that could store the trace of visited BasicVars
 * (when you try to get the distributions or values for some Basic or Derived
 * variables).
 * This class could also store the case levels in order to get the CBN decision
 * tree structure (useful for the Open Universe Gibbs Sampling).
 * 
 * @author Da Tang
 * @since Oct 27, 2014
 */
public class TraceLabelEvalContext extends TraceParentRecEvalContext {

  public TraceLabelEvalContext(PartialWorld world) {
    super(world);
  }

  protected TraceLabelEvalContext(
      PartialWorld world,
      LinkedHashMap<VarWithDistrib, ClassicInstantiatingEvalContext> respVarsAndContexts) {
    super(world, respVarsAndContexts);
  }

  protected Object getOrComputeValue(BasicVar var) {
    Object value = world.getValue(var);
    if (value == null) {
      numCalculateNewVars++;
      if (var instanceof VarWithDistrib) {
        value = instantiate((VarWithDistrib) var);
      } else {
        throw new IllegalArgumentException("Don't know how to instantiate: "
            + var);
      }
    }
    return value;
  }

  public Object getValue(BasicVar var) {
    Object value = getOrComputeValue(var);
    if (value == null) {
      latestUninstParent = var;
      var.ensureStable();
      handleMissingVar(var);
    } else {
      if (parents.add(var)) {
        var.ensureStable();
        parentTrace.addLast(var);
        caseLevelTrace.addLast(caseLevel);
        addCurLabelToClauseMap(var);
        if (currentClause != null) {
          clauseToVarMap.put(currentClause, var);
        }
      }
    }
    dependentVar.add(var);
    return value;
  }

  public NumberVar getPOPAppSatisfied(Object obj) {
    if (obj instanceof NonGuaranteedObject) {
      return ((NonGuaranteedObject) obj).getNumberVar();
    }

    if (obj instanceof ObjectIdentifier) {
      parents.add(new OriginVar((ObjectIdentifier) obj));
      parentTrace.addLast(new OriginVar((ObjectIdentifier) obj));
      caseLevelTrace.addLast(caseLevelTrace);
      addCurLabelToClauseMap(new OriginVar((ObjectIdentifier) obj));
      if (currentClause != null) {
        clauseToVarMap
            .put(currentClause, new OriginVar((ObjectIdentifier) obj));
      }
      return world.getPOPAppSatisfied(obj);
    }

    // Must be guaranteed object, so not generated by any number var
    return null;
  }

  protected Object instantiate(VarWithDistrib var) {
    var.ensureStable();

    /*
     * if (Util.verbose()) { System.out.println("Need to instantiate: " + var);
     * }
     */

    if (respVarsAndContexts.containsKey(var)) {
      cycleError(var);
    }

    // Create a new "child" context and get the distribution for
    // var in that context.
    respVarsAndContexts.put(var, this);
    TraceLabelEvalContext spawn = new TraceLabelEvalContext(world,
        respVarsAndContexts);
    spawn.afterSamplingListener = afterSamplingListener;
    DependencyModel.Distrib distrib = var.getDistrib(spawn);
    logProb += spawn.getLogProbability();
    respVarsAndContexts.remove(var);
    List parentTrace = spawn.getParentTrace(), caseLevelTrace = spawn
        .getCaseLevelTrace();
    for (int i = 0; i < parentTrace.size(); i++) {
      this.parentTrace.addLast(parentTrace.get(i));
      this.caseLevelTrace.addLast((Integer) caseLevelTrace.get(i)
          + this.caseLevel);
    }
    this.caseLevel += spawn.getCaseLevel();
    this.curRelatedClause = spawn.getCurRelatedClause();
    this.labelToRelatedClauseMap = spawn.getLabelToRelatedClauseMap();
    this.clauseToVarMap = spawn.getClauseToVarMap();

    // Sample new value for var
    CondProbDistrib cpd = distrib.getCPD();
    cpd.setParams(distrib.getArgValues());
    Object newValue = cpd.sampleVal();
    double logProbForThisValue = cpd.getLogProb(newValue);
    logProb += logProbForThisValue;

    // Assert any identifiers that are used by var
    Object[] args = var.args();
    for (int i = 0; i < args.length; ++i) {
      if (args[i] instanceof ObjectIdentifier) {
        world.assertIdentifier((ObjectIdentifier) args[i]);
      }
    }
    if (newValue instanceof ObjectIdentifier) {
      world.assertIdentifier((ObjectIdentifier) newValue);
    }

    // Actually set value
    world.setValue(var, newValue);

    if (afterSamplingListener != null) {
      afterSamplingListener.evaluate(var, newValue, logProbForThisValue);
    }

    if (staticAfterSamplingListener != null) {
      staticAfterSamplingListener.evaluate(var, newValue, logProbForThisValue);
    }

    /*
     * if (Util.verbose()) { System.out.println("Instantiated: " + var); }
     */

    return newValue;
  }

  public Object addRelatedClause(ArgSpec clause) {
    return curRelatedClause.add(clause);
  }

  public Object removeRelatedClause(ArgSpec clause) {
    return curRelatedClause.remove(clause);
  }

  public Object addClauseToVarRelation(ArgSpec clause, BayesNetVar var) {
    return clauseToVarMap.put(clause, var);
  }

  public Object addCurLabelToClauseMap(BayesNetVar var) {
    Set curClauseSet = new HashSet();
    curClauseSet.addAll(curRelatedClause);
    return labelToRelatedClauseMap.put(var, curClauseSet);
  }

  public Set getCurRelatedClause() {
    return curRelatedClause;
  }

  public MultiMap getLabelToRelatedClauseMap() {
    return labelToRelatedClauseMap;
  }

  public Map getClauseToVarMap() {
    return clauseToVarMap;
  }

  public void setCurrentClause(ArgSpec clause) {
    currentClause = clause;
  }

  protected Set curRelatedClause = new HashSet();
  protected MultiMap labelToRelatedClauseMap = new HashMultiMap();
  protected Map clauseToVarMap = new HashMap();
  protected ArgSpec currentClause;
}
