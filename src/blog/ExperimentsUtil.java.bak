package blog;

import java.util.*;

import common.DAEFunction;
import common.DependencyAwareEnvironment;
import common.EZIterator;
import common.GeometricSeriesIterator;
import common.Gnuplot;
import common.IntegerArithmeticSeriesIterator;
import common.IntegerGeometricSeriesIterator;
import common.NullaryFunction;
import common.RangeOperations;
import static common.RangeOperations.*;
import common.Util;
import common.Gnuplot.YSeries;

public class ExperimentsUtil {
    
    static int experimentLevel = 0; // 0 for very small, 1 for medium, 2 for complete
    static boolean plotAverageKLVsNumOfSamples = true; 
    static boolean plotComparisonBetweenLWAndPFVsNumOfSamples = false; 
    static boolean plotComparisonBetweenLWAndPFVsTimesteps = false; 
    static boolean plotKLVsNumOfSamplesAcrossEvidence = false; 
    
    static boolean truthDistributionWithSamplingEngine = false;
    
    private static String engineClassName = "blog.ParticleFilter";
    //private static String engineClassName = "blog.SamplingEngine";

    private static Problem problem = getUmbrella();
    static boolean randomize = true;
    
    private static void experimentLevel0() {
        numOfSamplesForTrueDistributionIfSampling = 1000;
        numOfSamplesForTrueDistributionIfParticleFilter = 400;
        evidenceSamples = 1;
        numOfRunsForAverage = 2;
        numSamples = 300;
        initialNumSamples = 100;
        numSamplesProgressRate = 1.1f;
        numSamplesStep = 100;
        finalTimestep = 10;
    }

    private static void experimentLevel1() {
        numOfSamplesForTrueDistributionIfSampling = 100000;
        numOfSamplesForTrueDistributionIfParticleFilter = 7000;
        evidenceSamples = 2;
        numOfRunsForAverage = 50;
        numSamples = 1000;
        initialNumSamples = 200;
        numSamplesProgressRate = 1.1f;
        numSamplesStep = 100;
        finalTimestep = 12;
    }

    private static void experimentLevel2() {
        numOfSamplesForTrueDistributionIfSampling = 600000;
        numOfSamplesForTrueDistributionIfParticleFilter = 6000;
        evidenceSamples = 10;
        numOfRunsForAverage = 50;
        numSamples = 6000;
        initialNumSamples = 100;
        numSamplesProgressRate = 1.1f;
        numSamplesStep = 100;
        finalTimestep = 20;
    }

    static String basicPrecommands = 
	"set xlabel font 'Arial, 15'\n" +
	"set ylabel font 'Arial, 15'\n" +
	"set title font 'Arial, 20'\n";
	
    static int numOfSamplesForTrueDistributionIfSampling;
    static int numOfSamplesForTrueDistributionIfParticleFilter;
    static int evidenceSamples;
    static int numOfRunsForAverage;
    static int initialNumSamples;
    static int numSamples;
    static float numSamplesProgressRate;
    static int numSamplesStep;
    static int finalTimestep;

    private static NullaryFunction sampleSizeIteratorNullaryFunction;
    private static NullaryFunction timestepsIteratorNullaryFunction;
    
    public static void experiment(Object ... args) {
	
	List data = (List) RangeOperations.run(args);

	PreCommands preCommands = getPreCommands(args);
	List axes = getAxes(args);
	YSeriesSpec seriesSpec = getSeriesSpec(args);
	
	Range xSeries = getXSeries(axes, seriesSpec);
	List ySeriesList = getYSeriesList(data, axes, seriesSpec);

	Gnuplot.plot(preCommands, xSeries, ySeriesList);
    }
    
    private static List getAxes(Object ... args) {
	List result = new LinkedList();
	for (Object object : args) {
	    if (object instanceof Axis)
		result.add(object);
	}
	return result;
    }
    
    private static class YSeriesSpec {
	public YSeriesSpec(String variable, List directivesList) {
	    this.variable = variable;
	    this.directivesList = directivesList;
	}
	private String variable;
	private List directivesList;
    }
    
    public static YSeriesSpec YSeriesSpec(String variable, List directivesList) {
	return new YSeriesSpec(variable, directivesList);
    }
    
    private static YSeriesSpec getSeriesSpec(Object... args) {
	return (YSeriesSpec) Util.getObjectOfClass(YSeriesSpec.class, args);
    }
    
    private static Range getXSeries(List axes, YSeriesSpec seriesSpec) {
	for (Iterator it = axes.iterator(); it.hasNext();) {
	    Axis axis = (Axis) it.next();
	    if ( ! axis.getRange().getName().equals(seriesSpec.variable))
		return axis.getRange();
	}
	return null;
    }
    
    private static Axis getSeriesAxis(List axes, YSeriesSpec seriesSpec) {
	for (Iterator it = axes.iterator(); it.hasNext();) {
	    Axis axis = (Axis) it.next();
	    if (axis.getRange().getName().equals(seriesSpec.variable))
		return axis;
	}
	return null;
    }
    
    private static List getYSeriesList(List data, List axes, YSeriesSpec seriesSpec) {
	List ySeriesList = new LinkedList();
	Axis ySeriesAxis = getSeriesAxis(axes, seriesSpec);
	int dimension = axes.indexOf(ySeriesAxis);
	Iterator rangeIterator = (Iterator) ySeriesAxis.getRange().evaluate();
	Iterator directiveIterator = seriesSpec.directivesList.iterator();
	int sliceIndex = 0;
	while(rangeIterator.hasNext()) {
	    rangeIterator.next();
	    List directives = (List) directiveIterator.next();
	    List ySeriesData = Util.matrixSlice(data, dimension, sliceIndex);
	    ySeriesList.add(new YSeries(directives, ySeriesData));
	    sliceIndex++;
	}
	return ySeriesList;
    }
    
    private static class PreCommands extends LinkedList {
	public PreCommands(String ... preCommands) {
	    addAll(Arrays.asList(preCommands));
	}
    }
    
    public static PreCommands preCommands(String ... preCommands) {
	return new PreCommands(preCommands);
    }
    
    
    public static PreCommands getPreCommands(Object ... args) {
	return (PreCommands) Util.getObjectOfClass(PreCommands.class, args);
    }
    
    public static void main(String[] args) {
	Util.initRandom(randomize);
	
	if (false)
	    experiment(
		    preCommands(
			    basicPrecommands,
			    "persist",
			    //"set term postscript color",
			    //"set output 'Comparison between LW and DBLOG PF (for one given piece of evidence).ps'",
			    "set title 'Comparison between LW and DBLOG PF (for one given piece of evidence)'",
			    "set xlabel 'Number of samples'",
			    "set ylabel 'Average KL divergence'"
		    ),
		    "problem", getWeatherWithoutAtemporal(),
		    "numSamplesForTrueDistribution", 100000,
		    Axis("inferenceEngineClassName", Util.list("blog.SamplingEngine", "blog.ParticleFilter")),
		    Axis("numSamples", 10, 1500, 100),
		    Averaging("run", 1, 10),
		    computeKLDivergence,
		    YSeriesSpec("inferenceEngineClassName", Util.list(
			    Util.list("title 'LW'", "w linespoints"),
			    Util.list("title 'DBLOG PF'","w linespoints"))));

	if (false) {
	    int finalTimestepIndex = 10;
	    experiment(
		    preCommands(
			    basicPrecommands,
			    "persist",
			    //"set term postscript color",
			    //"set output 'Comparison between LW and DBLOG PF as time progresses.ps'",
			    "set title 'Comparison between LW and DBLOG PF as time progresses'",
			    "set xlabel 'Number of time steps'",
			    "set ylabel 'Average KL divergence'"
		    ),
		    "problem", getWeatherWithoutAtemporal(),
		    "numSamplesForTrueDistribution", 50000,
		    "numSamples", 1000,
		    "finalTimestepIndex", finalTimestepIndex,
		    Axis("timestepIndex", 1, finalTimestepIndex),
		    Axis("inferenceEngineClassName", Util.list("blog.SamplingEngine","blog.ParticleFilter")),
		    Averaging("run", 1, 10),
		    computeKLDivergence,
		    YSeriesSpec("inferenceEngineClassName", Util.list(
			    Util.list("title 'LW'", "w linespoints"),
			    Util.list("title 'DBLOG PF'","w linespoints"))));
	}
	
	if (true) {
	    class RandomProblemIterator extends EZIterator { 
		public RandomProblemIterator(int numOfProblems, int finalTimestepIndex) {
		    this.numOfProblems = numOfProblems;
		    this.finalTimestepIndex = finalTimestepIndex;
		}
		public Object calculateNext() {
		    if (counter++ == numOfProblems) return null;
		    return getWeatherWithoutAtemporal().getRandomProblem(8); }
		private int numOfProblems;
		private int finalTimestepIndex;
		private int counter = 0;
	    };
	    class RandomProblemRange extends AbstractRange {
		public RandomProblemRange(String name, int numOfProblems, int finalTimestepIndex) {
		    super(name);
		    this.numOfProblems = numOfProblems;
		    this.finalTimestepIndex = finalTimestepIndex;
		}
		public Object evaluate() {  
		    return new RandomProblemIterator(numOfProblems, finalTimestepIndex); }
		private int numOfProblems;
		private int finalTimestepIndex;
	    };
	    
	    experiment(
		    preCommands(
			    basicPrecommands,
			    "persist",
			    //"set term postscript color",
			    //"set output 'PF performance (random evidence).ps'",
			    "set title 'Performance (over random evidence)'",
			    "set xlabel 'Number of samples'",
			    "set ylabel 'Average KL divergence'"
		    ),
		    "numSamplesForTrueDistribution", 50000,
		    Averaging("problem", new RandomProblemRange("problem", 2 /* num of problems */, 8 /* finalTimestepIndex */)),
		    Axis("numSamples", 10, 500, 100),
		    Axis("inferenceEngineClassName", Util.list("blog.SamplingEngine","blog.ParticleFilter")),
		    computeKLDivergence,
		    YSeriesSpec("inferenceEngineClassName", Util.list(
			    Util.list("title 'LW'", "w linespoints"),
			    Util.list("title 'DBLOG PF'","w linespoints"))));
	}

	System.exit(-1);

	if (experimentLevel == 0) {
	    experimentLevel0();
	}
	else if (experimentLevel == 1) {
	    experimentLevel1();
	}
	else if (experimentLevel == 2) {
	    experimentLevel2();
	}
	
//	NullaryFunction sampleSizeIteratorNullaryFunction = new NullaryFunction() { public Object evaluate() { return
//	    new IntegerArithmeticSeriesIterator(initialNumSamples, numSamples, numSamplesStep);}};
	
	sampleSizeIteratorNullaryFunction = new NullaryFunction() { public Object evaluate() { 
		return
		    new IntegerGeometricSeriesIterator(initialNumSamples, numSamples, numSamplesProgressRate);}
	};
			
	timestepsIteratorNullaryFunction = new NullaryFunction() { public Object evaluate() { 
	    return
	    new IntegerArithmeticSeriesIterator(0, finalTimestep, 1);}};

	if (plotAverageKLVsNumOfSamples)
	    plotAverageKLVsNumOfSamples(problem, sampleSizeIteratorNullaryFunction);

	if (plotComparisonBetweenLWAndPFVsNumOfSamples)
	    plotComparisonBetweenLWAndPFVsNumOfSamples(problem);

	if (plotComparisonBetweenLWAndPFVsTimesteps)
	    plotComparisonBetweenLWAndPFVsTimesteps(problem);
	    
	if (plotKLVsNumOfSamplesAcrossEvidence)
	    plotKLVsNumOfSamplesAcrossEvidence(problem);
    }

    private static void plotAverageKLVsNumOfSamples(
            Problem problem, NullaryFunction sampleSizeIteratorNullaryFunction) {
	
        ArgSpecQuery trueDistribution = getTrueDistribution(problem);
    
        List averageForGivenEvidenceList = 
            averageKLDivergenceVsNumSamples(
        	    problem, trueDistribution,
        	    engineClassName, (Iterator) sampleSizeIteratorNullaryFunction.evaluate());
        System.out.println("---------------------------");
        System.out.println("Average KL divergence over " + numOfRunsForAverage + " runs, increasing samples " + numSamplesStep + " at a time: " + averageForGivenEvidenceList);
        
        Gnuplot.plot(
        	Util.list( // pre-commands
        		basicPrecommands,
        		"persist",
        		//"set term postscript color",
        		//"set output 'DBLOG PF performance (for one given piece of evidence).ps'",
        		"set title 'DBLOG PF performance (for one given piece of evidence)'",
        		"set xlabel 'Number of samples'",
        		"set ylabel 'Average KL divergence'"
        	),
        	sampleSizeIteratorNullaryFunction, 
        	Util.list(new Gnuplot.YSeries(
        		Util.list("notitle", "w linespoints"),
        		averageForGivenEvidenceList)));
    }

    private static void plotComparisonBetweenLWAndPFVsNumOfSamples(Problem problem) {
        ArgSpecQuery trueDistribution = getTrueDistribution(problem);
	List lw = averageKLDivergenceVsNumSamples(problem, trueDistribution, "blog.SamplingEngine", (Iterator) sampleSizeIteratorNullaryFunction.evaluate());
	List pf = averageKLDivergenceVsNumSamples(problem, trueDistribution, "blog.ParticleFilter", (Iterator) sampleSizeIteratorNullaryFunction.evaluate());
        System.out.println("LW list: " + lw);
        System.out.println("PF list: " + pf);
    
        Gnuplot.plot(
        	Util.list( // precommands
        		basicPrecommands,
        		"persist",
        		//"set term postscript color",
        		//"set output 'Comparison between LW and DBLOG PF (for one given piece of evidence).ps'",
        		"set title 'Comparison between LW and DBLOG PF (for one given piece of evidence)'",
        		"set xlabel 'Number of samples'",
        		"set ylabel 'Average KL divergence'"
        	),
        	sampleSizeIteratorNullaryFunction, 
		Util.list( // list of ySeries
			new YSeries(
				Util.list("title 'LW'", "w linespoints"),
				lw
			),
			new YSeries(
				Util.list("title 'DBLOG PF'","w linespoints"),
				pf
			)
		));
    }

    private static void plotComparisonBetweenLWAndPFVsTimesteps(Problem problem) {
	problem = problem.getRandomProblem(finalTimestep);
	// Generates a single evidence all the way to the last time step.
	// Later, increasingly long segments of this same evidence will be used.
        //List lw = averageKLDivergenceVsTimesteps(problem, "blog.SamplingEngine", (Iterator) timestepsIteratorNullaryFunction.evaluate());
	List pf = averageKLDivergenceVsTimesteps(problem, "blog.ParticleFilter", (Iterator) timestepsIteratorNullaryFunction.evaluate());

        //System.out.println("LW list: " + lw);
        System.out.println("PF list: " + pf);

//        List difference = Util.componentWiseDifference(comparison[0], comparison[1]);
//        System.out.println("---------------------------");
//        System.out.println("Difference in average KL divergence over " + numOfRunsForAverage + " runs, increasing timestes, between LW and PF: " + difference);
    
        Gnuplot.plot(
        	Util.list( // precommands
        		basicPrecommands,
        		"persist",
        		//"set term postscript color",
        		//"set output 'Comparison between LW and DBLOG PF as time progresses.ps'",
        		"set title 'Comparison between LW and DBLOG PF as time progresses'",
        		"set xlabel 'Number of time steps'",
        		"set ylabel 'Average KL divergence'"
        	),
        	timestepsIteratorNullaryFunction, 
		Util.list( // list of ySeries
//			new YSeries(
//				Util.list("title 'LW'", "w linespoints"),
//				lw
//			),
			new YSeries(
				Util.list("title 'DBLOG PF'","w linespoints"),
				pf
			)
		));
    }

    private static void plotKLVsNumOfSamplesAcrossEvidence(
	    Problem meq) {
	List averageList = averageKLDivergenceVsNumSamplesAcrossEvidence(
		meq, engineClassName, sampleSizeIteratorNullaryFunction);
	System.out.println("---------------------------");
	System.out.println("Average KL divergence over " + numOfRunsForAverage + " runs, across " + evidenceSamples + " evidence samples, increasing samples " + numSamplesStep + " at a time: " + averageList);
	
	Gnuplot.plot(
		Util.list( // precommands
			basicPrecommands,
			"persist",
			//"set term postscript color",
			//"set output 'PF performance (random evidence).ps'",
			"set title 'DBLOG PF performance (over random evidence)'",
			"set xlabel 'Number of samples'",
			"set ylabel 'Average KL divergence'"
		),
		sampleSizeIteratorNullaryFunction, 
		Util.list(new Gnuplot.YSeries(Util.list("notitle","w linespoints"),averageList)));
    }

    private static ArgSpecQuery getTrueDistribution(Problem problem) {
        ArgSpecQuery trueDistributionQuery = new ArgSpecQuery(problem.query());
    
        Properties trueDistributionProperties = new Properties();
        trueDistributionProperties.setProperty("reportInterval", "-1");
        InferenceEngine trueDistributionEngine;
        if (truthDistributionWithSamplingEngine) {
            trueDistributionProperties.setProperty("numSamples", Integer.toString(numOfSamplesForTrueDistributionIfSampling));
            trueDistributionEngine = InferenceEngine.constructEngine("blog.SamplingEngine", problem.model, trueDistributionProperties);
        }
        else {
            trueDistributionProperties.setProperty("numSamples", Integer.toString(numOfSamplesForTrueDistributionIfParticleFilter));
            trueDistributionEngine = InferenceEngine.constructEngine("blog.ParticleFilter", problem.model, trueDistributionProperties);
        }
        
        answerQuery(trueDistributionQuery, problem.evidence, trueDistributionEngine);
    
        System.out.println("Results for true distribution query:");
        trueDistributionQuery.printResults(System.out);
        System.out.println("---------------------------");
    
        return trueDistributionQuery;
    }

    /**
     * Same as {@link #averageKLDivergenceVsNumSamples(Problem, ArgSpecQuery, String, Iterator)},
     * but averaging over <code>evidenceSamples</code> different pieces of random evidence up to the timestep previous to the query's.
     * @param problem TODO
     */
    public static List averageKLDivergenceVsNumSamplesAcrossEvidence(
	    Problem problem, String engineClassName,
	    NullaryFunction sampleSizeIteratorNullaryFunction) {
	int timestep = DBLOGUtil.getSingleTimestepIn(problem.query().argSpec()).intValue();
	List average = new LinkedList();
	for (int i = 0; i != evidenceSamples; i++) {
	    Problem newInstanceProblem = problem.getRandomProblem(timestep);
	    ArgSpecQuery trueDistribution = getTrueDistribution(newInstanceProblem);
	    List runResults = averageKLDivergenceVsNumSamples(newInstanceProblem, trueDistribution, engineClassName, (Iterator) sampleSizeIteratorNullaryFunction.evaluate());
	    Util.incrementalComputationOfComponentWiseAverage(average, i, runResults);
	}
	return average;
    }
    
    /**
     * Collects in a list, for each of the sample sizes in a iterator's range,
     * the corresponding average (over {@link #numOfRunsForAverage} runs)
     * of the KL divergence between a true posterior distribution
     * for a given query given model and evidence,
     * and the estimate given by an inference engine (whose class name is given).
     */
    public static List averageKLDivergenceVsNumSamples(
	    Problem meq, ArgSpecQuery trueDistribution,
	    String engineClassName,
	    Iterator sampleSizeIterator) {
	List result = new LinkedList();
	while (sampleSizeIterator.hasNext()) {
	    int sampleSize = ((Integer)sampleSizeIterator.next()).intValue();
	    double average = averageKLDivergence(meq, trueDistribution, engineClassName, sampleSize);
	    result.add(new Double(average));
	}
	return result;
    }
    
    /**
     * Collects in a list, for each of the time steps in a iterator's range,
     * the corresponding average (over {@link #numOfRunsForAverage} runs)
     * of the KL divergence between a true posterior distribution
     * for a given query given model and evidence,
     * and the estimate given by an inference engine (whose class name is given).
     */
    public static List averageKLDivergenceVsTimesteps(
	    Problem problem, String engineClassName, Iterator timestepIterator) {
	List result = new LinkedList();
	Evidence totalEvidence = problem.evidence;
	while (timestepIterator.hasNext()) {
	    int timestepIndex = ((Integer)timestepIterator.next()).intValue();
	    problem.evidence = DBLOGUtil.getEvidenceUpTo(timestepIndex - 1, totalEvidence);
	    problem.instantiateQueryTo(timestepIndex);
	    ArgSpecQuery trueDistribution = getTrueDistribution(problem);
	    double average = averageKLDivergenceAtTimestep(problem, trueDistribution, engineClassName, timestepIndex);
	    result.add(new Double(average));
	}
	problem.evidence = totalEvidence; // leave 'problem' the same way we found it.
	return result;
    }
    
    /**
     * Returns the average (over {@link #numOfRunsForAverage} runs)
     * of the KL divergence between a true posterior distribution
     * for a given query given model and evidence,
     * and the estimate given by an inference engine (whose class name is given),
     * for a given number of samples.
     */
    public static double averageKLDivergence(
	    final Problem problem, ArgSpecQuery trueDistribution,
	    String engineClassName,
	    int numSamples) {
	
	Properties testedProperties = new Properties();
	testedProperties.setProperty("numSamples", Integer.toString(numSamples));
	testedProperties.setProperty("reportInterval", "-1");
	final InferenceEngine testedEngine = InferenceEngine.constructEngine(engineClassName, problem.model, testedProperties);
	NullaryFunction getQuery = new NullaryFunction() { public Object evaluate() {
	    problem.query().zeroOut();
	    return answerQuery(problem.query(), problem.evidence, testedEngine);
	}};
	double average = averageKLDivergence(trueDistribution, getQuery);
	return average;
    }

    /**
     * Returns the average (over {@link #numOfRunsForAverage} runs)
     * of the KL divergence between a true posterior distribution
     * for a query and evidence up to a certain time step,
     * and the estimate given by an inference engine (whose class name is given),
     * for {@link #numSamples}.
     */
    public static double averageKLDivergenceAtTimestep(
	    final Problem problem, ArgSpecQuery trueDistribution, String engineClassName, int timestepIndex) {
	
	
	
	Properties testedProperties = new Properties();
	testedProperties.setProperty("numSamples", Integer.toString(numSamples));
	testedProperties.setProperty("reportInterval", "-1");
	final InferenceEngine testedEngine = InferenceEngine.constructEngine(engineClassName, problem.model, testedProperties);

	NullaryFunction getQuery = new NullaryFunction() { public Object evaluate() {
	    problem.query().zeroOut();
	    return answerQuery(problem.query(), problem.evidence, testedEngine);
	}};
	
	double average = averageKLDivergence(trueDistribution, getQuery);
	return average;
    }

    /**
     * Obtains a series of {@link #numOfRunsForAverage} queries from a nullary function and compute the average KL divergence
     * from them to a true distribution given query.
     */
    public static double averageKLDivergence(ArgSpecQuery trueDistribution, NullaryFunction getQuery) {
        double sum = 0;
        for (int i = 0; i != numOfRunsForAverage; i++) {
            ArgSpecQuery query = (ArgSpecQuery) getQuery.evaluate();
            query.printResults(System.out);
            double kl = klDivergence(query, trueDistribution);
            sum += kl;
        }
        return sum/numOfRunsForAverage;
    }

    public static double klDivergence(ArgSpecQuery query1, ArgSpecQuery query2) {
	Set entries = new HashSet();
	entries.addAll(query1.elementSet());
	entries.addAll(query2.elementSet());
	
	double sum = 0;
	for (Iterator it = entries.iterator(); it.hasNext(); ) {
	    Object entry = it.next();
	    double p1 = query1.getProb(entry);
	    double p2 = query2.getProb(entry);
	    double log = Util.log2(p1 / p2);
	    sum += p1 * Util.log2(p1 / p2);
	}
	return sum;
    }
    
    private static DAEFunction computeKLDivergence = new DAEFunction() { public Object evaluate(DependencyAwareEnvironment environment) {
	ArgSpecQuery trueDistribution      = (ArgSpecQuery) environment.getResultOrRecompute(computeTrueDistribution);
	ArgSpecQuery estimatedDistribution = (ArgSpecQuery) environment.getResultOrRecompute(computeEstimatedDistribution);
	double divergence = klDivergence(trueDistribution, estimatedDistribution);
	System.out.println("True distribution of " + trueDistribution);
	trueDistribution.printResults(System.out);
	System.out.println("Estimated distribution of " + estimatedDistribution);
	estimatedDistribution.printResults(System.out);
	System.out.println("KL divergence: " + divergence);
	return divergence;
    }};
    
    private static DAEFunction computeTrueDistribution = new DAEFunction() { public Object evaluate(DependencyAwareEnvironment environment) {
	return computeQuery(environment, "inferenceEngineForTrueDistributionClassName", "numSamplesForTrueDistribution");
    }};

    private static DAEFunction computeEstimatedDistribution = new DAEFunction() {
	public boolean isRandom() { return true; }                             public Object evaluate(DependencyAwareEnvironment environment) {
	return computeQuery(environment, "inferenceEngineClassName", "numSamples");
    }};
    
    private static DAEFunction getTotalEvidence = new DAEFunction() { public Object evaluate(DependencyAwareEnvironment environment) {
	int finalTimestepIndex = environment.getInt("finalTimestepIndex");
        Problem problem = (Problem) environment.get("problem");
        return TemporalEvidenceGenerator.collectEvidenceUpTo(finalTimestepIndex - 1, problem.model, problem.linkStrings);
    }};
    
    private static DAEFunction getEvidenceUpToTimestepIndexMinus1 = new DAEFunction() { public Object evaluate(DependencyAwareEnvironment environment) {
	int timestepIndex = environment.getInt("timestepIndex");
        Evidence totalEvidence = (Evidence) environment.getResultOrRecompute(getTotalEvidence);
        return DBLOGUtil.getEvidenceUpTo(timestepIndex -1, totalEvidence);
    }};
    
    private static DAEFunction getQueryTemplateInstantiatedToTimestepIndex = new DAEFunction() { public Object evaluate(DependencyAwareEnvironment environment) {
	int timestepIndex = environment.getInt("timestepIndex");
        Problem problem = (Problem) environment.get("problem");
        return problem.getInstantiatedQuery(timestepIndex);
    }};
    
    private static DAEFunction getRandomProblem = new DAEFunction() { public Object evaluate(DependencyAwareEnvironment environment) {
	environment.get("problemRun");
	int finalTimestepIndex = environment.getInt("finalTimestepIndex");
        Problem problem = (Problem) environment.get("problem");
        return problem.getRandomProblem(finalTimestepIndex);
    }};
    
    private static Object computeQuery(
	    DependencyAwareEnvironment environment,
            String inferenceEngineClassNamePropertyName, String numSamplesPropertyName) {
        String engineClassName = (String) environment.getWithDefault(inferenceEngineClassNamePropertyName, "blog.SamplingEngine");
        Problem problem = (Problem) environment.get("problem");
        Integer numSamples = (Integer) environment.get(numSamplesPropertyName);
    
        Properties properties = new Properties();
        properties.setProperty("reportInterval", "-1");
        properties.setProperty("numSamples", numSamples.toString());
        
        InferenceEngine engine = InferenceEngine.constructEngine(engineClassName, problem.model, properties);
    
        ArgSpecQuery query;
        Evidence evidence;
        
        if (environment.containsKey("timestepIndex")) {
            evidence = (Evidence) environment.getResultOrRecompute(getEvidenceUpToTimestepIndexMinus1);
            query = (ArgSpecQuery) environment.getResultOrRecompute(getQueryTemplateInstantiatedToTimestepIndex);
        }
        else {
            evidence = problem.evidence;
            query = problem.query();
        }
        
        query = new ArgSpecQuery(query); // the query is also its own result, so we need to create new queries for storing new results.

        engine.solve(query, evidence);
        return query;
    }

    private static ArgSpecQuery answerQuery(final ArgSpecQuery query, final Evidence evidence,
	    InferenceEngine engine) {
	engine.setEvidence(evidence);
	engine.setQueries(Util.list(query));
	engine.answerQueries();
	return query;
    }

    private static Problem getTestExample() {
	String modelDescription = 
	"type RainEvent;" +
	"guaranteed RainEvent Rainy, Dry;" +

	"random RainEvent Weather(Timestep);" +
	"random Boolean RainyRegion();" +

	"RainyRegion ~ Bernoulli[0.5]();" +

	"Weather(d) ~ TabularCPD[[0.3, 0.7],[0.7, 0.3]](RainyRegion);" +
	"" +
	"random NaturalNum Indicator();" +
	"Indicator ~ TabularCPD[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]](RainyRegion, Weather(@0));";
	
	String queryString = "query Indicator;";
	
	String evidenceString =
	    "obs Weather(@0)=Rainy;";
	
	List linkStrings = Util.list("Weather(t)");
	
	String queryTemplate = "query Indicator;";
		
	return new Problem(modelDescription, evidenceString, queryString, linkStrings, queryTemplate);
    }

    private static Problem getUmbrella() {
	String modelDescription = 
	"type RainEvent;" +
	"guaranteed RainEvent Rainy, Dry;" +

	"random RainEvent Weather(Timestep);" +

	"Weather(d) " +
	" 	if (d = @0) then ~ TabularCPD[[0.2, 0.8]]()" +
	"	else ~ TabularCPD[[0.2, 0.8]," +
	"	                  [0.1, 0.9]]" +
	"	             (Weather(Prev(d)));" +
	"" +
	"random Boolean Umbrella(Timestep);" +
	"Umbrella(d) ~ TabularCPD[[0.8, 0.2]," +
	"                         [0.2, 0.8]]" +
	"                      (Weather(d));";
	
	String queryString = "query Weather(@8);";
	
	String evidenceString =
	    "obs Umbrella(@0) = true;" +
	    "obs Umbrella(@1) = false;" +
	    "obs Umbrella(@2) = true;" +
	    "obs Umbrella(@3) = false;" +
	    "obs Umbrella(@4) = false;" +
	    "obs Umbrella(@5) = false;" +
	    "obs Umbrella(@6) = true;" +
	    "obs Umbrella(@7) = false;"
	    ;
	
	List linkStrings = Util.list("Umbrella(t)");
	
	String queryTemplate = "query Umbrella(t);";
		
	return new Problem(modelDescription, evidenceString, queryString, linkStrings, queryTemplate);
    }
    
    private static Problem getAircraft() {
	String modelDescription = 
	    "type Aircraft;" +
	    "#Aircraft ~ Poisson[3];" +

	    "type Blip;" +
	    "origin Aircraft Source(Blip);" +
	    "origin Timestep Time(Blip);" +
	    "#Blip(Source = a, Time = t) ~ TabularCPD[[0.9, 0.1]]();" +

	    "#Blip(Time = t) ~ Poisson[2];" +
	    "" +
	    "random Boolean twoAircraft;" +
	    "twoAircraft ~ TabularCPD[[0.0, 1.0], [0.0, 1.0], [1.0, 0.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0], [0.0, 1.0]](#{Aircraft a});" +
	    "";

	String queryString = "query twoAircraft;";
	
	String evidenceString =
	    "obs {Blip b : Time(b) = @0} = {B01, B02, B03};" +
	    "obs {Blip b : Time(b) = @1} = {B11, B12};" +
	    "obs {Blip b : Time(b) = @2} = {B21};" +
	    "obs {Blip b : Time(b) = @3} = {B31, B32, B33};" +
	    "obs {Blip b : Time(b) = @4} = {B41};" +
	    "obs {Blip b : Time(b) = @5} = {B51, B52};" +
	    "obs {Blip b : Time(b) = @6} = {B61, B62};" +
	    "obs {Blip b : Time(b) = @7} = {B71, B72};" +
	    "";
	
	List linkStrings = Util.list("#{Blip b : Time(b) = t}");
	
	String queryTemplate = "query twoAircraft;";
		
	return new Problem(modelDescription, evidenceString, queryString, linkStrings, queryTemplate);
    }
    
    private static Problem getHMM() {
	String modelDescription = 
	"type State;" +
	"guaranteed State s1, s2, s3, s4;" +

	"random State StateAt(Timestep);" +

	"StateAt(t) " +
	" 	if (t = @0) then ~ TabularCPD[[0.3, 0.3, 0.3, 0.1]]()" +
	"	else ~ TabularCPD[[0.3, 0.3, 0.3, 0.1]," +
	"	                  [0.3, 0.3, 0.3, 0.1]," +
	"	                  [0.3, 0.3, 0.3, 0.1]," +
	"                         [0.04, 0.03, 0.03, 0.9]]" +
	"	             (StateAt(Prev(t)));" +
	"" +
	"random Boolean Observation(Timestep);" +
	"Observation(t) ~ TabularCPD[[0.9, 0.1]," +
	"	                     [0.9, 0.1]," +
	"	                     [0.9, 0.1]," +
	"                            [0.1, 0.9]]" +
	"                          (StateAt(t));";
	
	String queryString = "query StateAt(@8);";
	
	String evidenceString =
	    "obs Observation(@0)=true;" +
	    "obs Observation(@1)=false;" +
	    "obs Observation(@2)=true;" +
	    "obs Observation(@3)=true;" +
	    "obs Observation(@4)=false;" +
	    "obs Observation(@5)=false;" +
	    "obs Observation(@6)=false;" +
	    "obs Observation(@7)=true;";
	
	List linkStrings = Util.list("Observation(t)");
	
	String queryTemplate = "query StateAt(t);";
		
	return new Problem(modelDescription, evidenceString, queryString, linkStrings, queryTemplate);
    }
    
    private static Problem getWeatherWithoutAtemporal() {
	String modelDescription = 
	"type RainEvent;" +
	"guaranteed RainEvent Rainy, Dry;" +

	"random RainEvent Weather(Timestep);" +

	"Weather(d) " +
	" 	if (d = @0) then ~ TabularCPD[[0.7, 0.3]]()" +
	"	else ~ TabularCPD[[0.8, 0.2]," +
	"	                  [0.3, 0.7]]" +
	"	             (Weather(Prev(d)));";
	
	String queryString = "query Weather(@1);";
	
	String evidenceString = "";
	
	List linkStrings = Util.list("Weather(t)");
	
	String queryTemplate = "query Weather(t);";
		
	return new Problem(modelDescription, evidenceString, queryString, linkStrings, queryTemplate);
    }
    
    private static Problem getWeatherWithAtemporal() {
	String modelDescription = 
	"type RainEvent;" +
	"guaranteed RainEvent Rainy, Dry;" +

	"random RainEvent Weather(Timestep);" +
	"random Boolean RainyRegion();" +

	"RainyRegion ~ Bernoulli[0.5]();" +

	"Weather(d) " +
	" 	if (d = @0) then ~ TabularCPD[[0.7, 0.3],[0.3, 0.7]](RainyRegion)" +
	"	else ~ TabularCPD[[0.8, 0.2]," +
	"	                  [0.3, 0.7]," +
	"	                  [0.5, 0.5]," +
	"	                  [0.2, 0.8]]" +
	"	             (RainyRegion, Weather(Prev(d)));";
	
	String queryString = "query Weather(@1);";
	
	String evidenceString =
	    "obs Weather(@0)=Rainy;" +
	    "obs Weather(@1)=Rainy;" +
	    "obs Weather(@2)=Rainy;" +
	    "obs Weather(@3)=Rainy;" +
	    "obs Weather(@4)=Rainy;" +
	    "obs Weather(@5)=Dry;";
	
	List linkStrings = Util.list("Weather(t)");
	
	String queryTemplate = "query Weather(t);";
		
	return new Problem(modelDescription, evidenceString, queryString, linkStrings, queryTemplate);
    }
    
    private static class Problem {
	public Problem(Model model, Evidence evidence, List queries, Collection linkStrings, String queryTemplate) {
	    this.model = model;
	    this.evidence = evidence;
	    this.queries = queries;
	    this.linkStrings = linkStrings;
	    this.queryTemplate = queryTemplate;
	}

	public Problem(String modelDescription, String evidenceString, String queriesString, Collection linkStrings, String queryTemplate) {
	    this.model = BLOGUtil.parseModel_NE(modelDescription);
	    this.evidence = BLOGUtil.parseEvidence_NE(evidenceString, model);
	    this.queries = Util.list(BLOGUtil.parseQuery_NE(queriesString, model));
	    this.linkStrings = linkStrings;
	    this.queryTemplate = queryTemplate;
	}
	
	public Problem(Problem another) {
	    this.model = another.model;
	    this.evidence = another.evidence;
	    this.queries = Util.list();
	    for (Iterator it = another.queries.iterator(); it.hasNext();) {
		ArgSpecQuery query = (ArgSpecQuery) it.next();
		this.queries.add(new ArgSpecQuery(query));
	    } // duplicate queries because results are stored in them
	    this.queries = another.queries;
	    this.linkStrings = another.linkStrings;
	    this.queryTemplate = another.queryTemplate;
	}
	
	/** Convenience method assuming there is only one query, of class ArgSpecQuery, and returning it. */
	public ArgSpecQuery query() {
	    return (ArgSpecQuery) Util.getFirst(queries);
	}
	
	/**
	 * Returns a problem which instantiates this problem with a query and evidence
	 * according to a given time step.
	 */
	public Problem getRandomProblem(int t) {
	    Problem result = new Problem(this);
	    result.instantiateQueryTo(t);
	    result.evidence = TemporalEvidenceGenerator.collectEvidenceUpTo(t - 1, model, linkStrings);
	    return result;
	}

	private void instantiateQueryTo(int t) {
	    queries = Util.list(getInstantiatedQuery(t));
	}

	/**
	 * Returns the query template instantiated to a given time step index.
	 */
	public ArgSpecQuery getInstantiatedQuery(int t) {
	    return TemporalQueriesInstantiator.getQuery(queryTemplate, t, model);
	}

	public Model model;
	public Evidence evidence;
	public List queries;
	public Collection linkStrings;
	public String queryTemplate;
    }
}
