/*
 * Copyright (c) 2005, 2012, 2013, 2014, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * * Neither the name of the University of California, Berkeley nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior
 *   written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * use JFlex
 * @author leili
 * @author bramsundar
 * @author tejas
 * @date 2014-06
 */

package blog.parse;
import java_cup.runtime.*;
import blog.absyn.*;


action code {:

  static blog.symbol.Symbol sym(String s) {
           return blog.symbol.Symbol.Symbol(s);
  }

  LocationInFile getCurLocation() {
    return new LocationInFile
      (((ScannerWithLocInfo)parser.getScanner()).getCurFilename(),
      ((ScannerWithLocInfo)parser.getScanner()).getCurLineNum());
  }

  int currLineno() {
    ScannerWithLocInfo scanner =  ((ScannerWithLocInfo)parser.getScanner());
    return scanner.getCurLineNum();
  }

  int currColno() {
    return ((ScannerWithLocInfo)parser.getScanner()).getCurColNum();
  }

  void error(String msg) {
    error(currLineno(), currColno(), msg);
  }

  void error(int line, int col, String msg) {
    parser.errorMsg.error(line, col, msg);
  }

  void error(Location s, String msg){
    parser.errorMsg.error(s.getLine(), s.getColumn(), msg);
  }

  void warning( String message ){
    System.err.println("\n" + curr_filename( ) + ":" + currLineno( )
                            + " Warning: " + message);
  }

  String curr_filename() {
    return ((ScannerWithLocInfo)parser.getScanner()).getCurFilename();
  }
:}


parser code {:
  Absyn parseResult; //variable to store the final parsing result
  blog.msg.ErrorMsg errorMsg; //for error

  public Absyn getParseResult() {
    return parseResult;
  }
  
  public BLOGParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf, blog.msg.ErrorMsg msg) {
    this(s, sf);
    errorMsg = msg;
  }

// WC: Methods that get automatically invoked when using the builtin error recovery mechanism.  
/*
public void report_error(String message, Object info)
    This method should be called whenever an error message is to be issued. In the default implementation of this method, the first parameter provides the text of a message which is printed on System.err and the second parameter is simply ignored. It is very typical to override this method in order to provide a more sophisticated error reporting mechanism. 
public void report_fatal_error(String message, Object info)
    This method should be called whenever a non-recoverable error occurs. It responds by calling report_error(), then aborts parsing by calling the parser method done_parsing(), and finally throws an exception. (In general done_parsing() should be called at any point that parsing needs to be terminated early). 
public void syntax_error(Symbol cur_token)
    This method is called by the parser as soon as a syntax error is detected (but before error recovery is attempted). In the default implementation it calls: report_error("Syntax error", null);. 
public void unrecovered_syntax_error(Symbol cur_token)
    This method is called by the parser if it is unable to recover from a syntax error. In the default implementation it calls: report_fatal_error("Couldn't repair and continue parse", null);. 
*/
:}

init with {:

:}

/* Terminal declarations; a few have types for associated lexemes.  The
 * token ERROR is never used in the parser; thus, it is a parse error when
 * the lexer returns it. For the terminals' interpretations, consult with
 * BLOGLexer.lex.
 */
terminal ELSE, IF, THEN;
terminal TYPE, RANDOM, FIXED, ORIGIN, DISTINCT,
        QUERY, OBS, PARAM, LIST, MAP, DISTRIBUTION;
terminal EXISTS, FORALL;
terminal FOR;
terminal NULL;
terminal java.lang.Number INT_LITERAL, DOUBLE_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHAR_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String ID;
//terminal PARFACTOR, FACTOR; // Not Yet Implemented
terminal AT; // time operator
terminal PLUS, MINUS, MULT, DIV, MOD, POWER; //arithmetic operator
terminal LT, GT, LEQ, GEQ; // relational_expression
terminal EQEQ, NEQ; // equality compare
terminal EQ; // assignment operator
terminal DISTRIB;
terminal NOT, AND, OR, DOUBLERIGHTARROW; // logical operator
terminal COMMA, SEMI, COLON, DOT, NUMSIGN, RIGHTARROW; //seperators
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET; // paired seperators

nonterminal program;
nonterminal StmtList opt_statement_lst, statement_lst;
nonterminal Stmt statement, declaration_stmt, type_decl, fixed_func_decl,
  rand_func_decl, number_stmt, origin_func_decl,
  distinct_decl, distribution_decl, parameter_decl,
  evidence_stmt, query_stmt;
nonterminal Stmt evidence, value_evidence, symbol_evidence, query;
nonterminal Expr expression, literal, operation_expr, unary_operation_expr,
  quantified_formula, distribution_expr,
  function_call, list_construct_expression,
  map_construct_expression, number_expr, elseif_list;
nonterminal Expr dependency_statement_body;
nonterminal SetExpr set_expr;
nonterminal ExplicitSetExpr explicit_set;
nonterminal ImplicitSetExpr implicit_set;
nonterminal TupleSetExpr tuple_set;
nonterminal ExprList semi_colon_separated_expression_list,
  opt_expression_list, expression_list;
nonterminal ExprTupleList expression_pair_list;
nonterminal Ty type, list_type, map_type;
nonterminal ArrayTy array_type;
nonterminal String array_type_or_sub;

//attempt catch disctint decl errors
nonterminal SymbolArray bracket_error;
nonterminal String brackets;

//attempt catch type var list errors
nonterminal String extra_commas, extra_types;

//attempt catch func decl errors
nonterminal String paren, extra_parens;
nonterminal String extra_lparens, extra_rparens;

//attempt catch expression errors
nonterminal String binop;

nonterminal String IDS;
nonterminal String EQS;
nonterminal String SEMIS;

//nonterminal Integer dims; //not used
//nonterminal FieldList opt_parenthesized_type_lst, type_lst // Not Used
nonterminal FieldList opt_parenthesized_type_var_lst, type_var_lst;
nonterminal OriginFieldList opt_parenthesized_origin_var_list,
  origin_var_list;
nonterminal SymbolArray id_or_subid;
nonterminal SymbolArrayList id_or_subid_list;
nonterminal String refer_name;


/*
 * Precedence declarations.  The later the precedence declaration, the
 * higher the precedence.
 */
precedence left ELSE;
precedence nonassoc EQ, DISTRIB;
precedence right RIGHTARROW;
precedence left DOUBLERIGHTARROW;
precedence left AND, OR;
precedence nonassoc LT, GT, LEQ, GEQ, EQEQ, NEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, POWER;
precedence right NOT, AT;
precedence left ID;
precedence left RPAREN, RBRACKET, RBRACE;
precedence right LBRACKET, LPAREN;
precedence left SEMI, error;

/* Grammar *******************************************************************/

start with program;


/* The start nonterminal */
program ::= opt_statement_lst : e {: parser.parseResult = e;  :}
  | error {: 
    error("invalid syntax"); 
    RESULT = null; 
  :}
  ;

/* Represents a possibly-empty list of statements. */
opt_statement_lst ::= /* EMPTY */ {: RESULT = null; :}
  | statement_lst : e {: RESULT = e; :}
  | statement:e 
  {: error("Possible cause: forgotten semicolon" ); 
       if (e==null) RESULT = null;
       else RESULT = new StmtList(e, null);    
  :}       
  ;

/* Represents a non-empty list of statements terminated by semicolons. */
statement_lst ::= statement:e SEMI statement_lst:slst
    {: if (e==null) RESULT = slst;
       else RESULT = new StmtList(e, slst);
    :}
  | statement:e SEMI {: if (e!=null) RESULT = new StmtList(e, null); 
                        else RESULT = null; :}
  | statement:e statement_lst:slst
    {: error(exright, "Possible cause: forgotten semicolon"); 
       if (e==null) RESULT = slst;
       else RESULT = new StmtList(e, slst);
    :}
  | error SEMI {: RESULT = null; :}
;

/* A statement can be a declaration, an observation (assertion of some
 * evidence), or a query.
 */
statement ::= declaration_stmt : e {: RESULT = e; :}
  | evidence_stmt : e {: RESULT = e; :}
  | query_stmt : e {: RESULT = e; :}
  ;

/* Represents a declaration, which can be:
 *    * a type declaration;
 *    * a parameter declaration;
 *    * a random function or generating function declaration
 *        (Semantic checks:
 *            - whether the return type is a declared type;
 *            - whether the argument types have been declared (an error-check
 *      propagated from the type_lst production.);
 *    * a random function definition
 *    * a non-random function (or constant) declaration
 *    * a non-random function (or constant) definition, specifying the
 *      interpretation of the function
 *    * a random function dependency statement description
 *        (Semantic checks:
 *        - whether the numbers of actual and declared parameters match;
 *            - whether the function by this name has been declared.);
 *    * a guaranteed object declaration
 *        (Semantic checks:
 *            - whether the type has been declared.);
 *    * a POP number statement description
 *        (Semantic checks:
 *            - whether the numbers of generating functions and parameters
 *                match;
 *            - whether the generating functions have been declared (an
 *                error-check propagated from the function_lst production);
 *            - whether each generating function takes exactly one parameter (an
 *                error-check propagated from the function_lst production);
 *            - whether the only parameter of each generating function is of the
 *                type being generated.).
 *    * a parfactor statement // not used in current blog
 */
declaration_stmt ::=
    type_decl:e {: RESULT = e; :}
  | fixed_func_decl:e {: RESULT = e; :}
  | rand_func_decl:e {: RESULT = e; :}
  | origin_func_decl : e {: RESULT = e; :}
  | number_stmt : e {: RESULT = e; :}
  | distinct_decl : e {: RESULT = e; :}
  | parameter_decl : e {: RESULT = e; :}
  | distribution_decl :e {: RESULT = e; :}
/*  | parfactor : e {: RESULT = e; :}  */
  ;

type_decl ::= TYPE ID:typename 
    {: RESULT = new TypeDec(currLineno(), currColno(), sym(typename)); :}
  | TYPE:ty error
    {: error(tyxright, "malformed or missing id"); :}  
  ;

/*
 * Represents a type that is built in or has already been declared.
 * can also be an array
 */
type ::= refer_name:typename
    {: RESULT = new NameTy(currLineno(), currColno(), sym(typename)); :}
  | list_type:e {: RESULT = e; :}
  | array_type : at {: RESULT = at; :}
  | map_type:e {: RESULT = e; :}
  ;

list_type ::= LIST LT refer_name:typename GT
    /* here general name is allowed, but internally only allow nametype as list */
    {: RESULT = new ListTy(currLineno(), currColno(), 
      new NameTy(currLineno(), currColno(), sym(typename))); :}
  ;

array_type_or_sub ::= refer_name:typename LBRACKET
  {: RESULT = typename; :}
  ;

array_type ::= array_type_or_sub:typename RBRACKET
    /* internally only allow nametype as array */
    {: RESULT = new ArrayTy(currLineno(), currColno(), 
      new NameTy(currLineno(), currColno(), sym(typename)), 1); :} 
  | array_type : arrty LBRACKET RBRACKET
    {: arrty.dim += 1; 
      RESULT = arrty; :} 
  ;

map_type ::= MAP LT type:t1 COMMA type:t2 GT
    {: RESULT = new MapTy(currLineno(), currColno(), t1, t2); :}
  ;

/* A possibly empty list of IDs denoting type names. */
// Currently commented this code out since it isn't being
// used anywhere else in this cup file and cup is giving
// warnings. Uncomment once these rules are used elsewhere.
//   
//opt_parenthesized_type_lst ::= /* EMPTY */
//      {: RESULT = null; :}
//      | LPAREN RPAREN
//      {: RESULT = null; :}
//      | LPAREN type_lst:tl RPAREN
//      {: RESULT = tl; :}
//      ;

//type_lst ::= type:ty COMMA type_lst:tl
//    {: RESULT = new FieldList(null, ty, tl); :}
//  | type:ty
//    {: RESULT = new FieldList(null, ty, null); :}
//  ;

/* Represents a list of IDs denoting type names. */
opt_parenthesized_type_var_lst ::= /* EMPTY */
    {: RESULT = null; :}
  | LPAREN RPAREN
    {: RESULT = null; :}
  | LPAREN type_var_lst:tl RPAREN
    {: RESULT = tl; :}
  | RPAREN:rp type_var_lst:tl LPAREN
    {: error(rpxleft, "mismatched parentheses"); RESULT = null; :}
  | extra_lparens:el type_var_lst:tl RPAREN
    {: error(elxleft, "too many parentheses"); RESULT = null; :}
  | LPAREN type_var_lst:tl extra_rparens:er
    {: error(erxleft, "too many parentheses"); RESULT = null; :}
  | extra_lparens:el type_var_lst:tl extra_rparens
    {: error(elxleft, "too many parentheses"); RESULT = null; :}
  ;

extra_commas ::= COMMA COMMA
    {: RESULT = "uh oh";:}
  | extra_commas COMMA
    {: RESULT = "uh oh";:}
  ;

extra_types ::= type:ty type:ty2
    {: RESULT = "uh oh";:}
  | extra_types type:ty
    {: RESULT = "uh oh";:}
  ;

type_var_lst ::= type:ty ID:id COMMA type_var_lst:tl
    {: RESULT = new FieldList(sym(id), ty, tl); :}
  | type:ty ID:id
    {: RESULT = new FieldList(sym(id), ty, null); :}
  | type:ty ID:id COMMA 
    {: error(idxright, "extra comma"); RESULT = null;:}
  | type:ty ID:id extra_commas type_var_lst:tl
    {: error(idxright, "extra commas"); RESULT = null;:}
  | type:ty ID:id type_var_lst:tl
    {: error(idxright, "missing comma"); RESULT = null;:}
  | type:ty COMMA type_var_lst:tl
    {: error(tyxright, "missing id"); RESULT = null;:}
  | extra_types:ety ID:id COMMA type_var_lst:tl
    {: error(etyxright, "extra types"); RESULT = null;:}
  ;

/* A nonrandom function declaration may declare a nonrandom constant or
 * a non-random function.  The distinction is whether there is a
 * parenthesized list of arguments after the function/constant name.
 */
fixed_func_decl ::=
    FIXED:fx type:ret_type ID:fname opt_parenthesized_type_var_lst:otl
    EQ expression:ex
    {: RESULT = new FixedFuncDec(fxxleft.getLine(), fxxleft.getColumn(), sym(fname), otl, ret_type, ex); :}
    | FIXED type:ret_type ID:fname error:err
    EQ expression:ex
    {: error(errxleft, "malformed type variable list"); :}
    | FIXED type:ret_type ID:fname opt_parenthesized_type_var_lst:otl
    error:err
    {: error(errxleft, "malformed function body"); :}
  ;

/**
 * random function declaration
 * including dependency statement
 */
rand_func_decl ::=
    RANDOM type:ret_type ID:fname opt_parenthesized_type_var_lst:otl
    dependency_statement_body:body 
    {: RESULT = new RandomFuncDec(currLineno(), currColno(), sym(fname), otl, ret_type, body); :}
    | RANDOM type:ret_type ID:fname error:err dependency_statement_body:body
    {: error(errxleft, "malformed type variable list"); :}
    | RANDOM type:ret_type ID:fname opt_parenthesized_type_var_lst:otl error:err
    {: error(errxleft, "malformed dependency statement body"); :}
   ;

/**
 * number statement
 */
number_stmt ::=
    NUMSIGN refer_name:ty opt_parenthesized_origin_var_list:otl
  dependency_statement_body:body
    {: RESULT = new NumberDec(currLineno(), currColno(), 
    new NameTy(currLineno(), currColno(), sym(ty)), otl, body); :}
   | NUMSIGN:ns opt_parenthesized_origin_var_list:otl
  dependency_statement_body:body 
    {: error(nsxright, "missing type name"); RESULT = null; :}
   | NUMSIGN error:err dependency_statement_body:body
   {: error(errxleft, "error in origin variable list"); :}
   | NUMSIGN refer_name:ty opt_parenthesized_origin_var_list:otl
  error:err
    {: error(errxleft, "error in number statement body"); RESULT = null; :}
  ;

paren ::= LPAREN {:RESULT = null;:}
  | RPAREN {:RESULT = null;:}
  ;

extra_parens ::= paren paren {:RESULT = null;:}
  | extra_parens paren {:RESULT = null;:}
  ;

extra_lparens ::= LPAREN LPAREN {:RESULT = null;:}
  | extra_lparens LPAREN {:RESULT = null;:}
  ;

extra_rparens ::= RPAREN RPAREN {:RESULT = null;:}
  | extra_rparens RPAREN {:RESULT = null;:}
  ;

opt_parenthesized_origin_var_list ::= LPAREN origin_var_list:e RPAREN
    {: RESULT = e; :}
  | extra_parens:ep origin_var_list:e extra_parens 
    {: error(epxleft, "unmatched parentheses"); RESULT = e;:}
  | LPAREN:lp origin_var_list:e extra_parens 
    {: error(lpxleft, "unmatched parentheses"); RESULT = e;:}
  | extra_parens:ep origin_var_list:e RPAREN
    {: error(epxleft, "unmatched parentheses"); RESULT = e;:}
  | {: RESULT = null; :}
  ;

EQS ::= EQ EQ
  | EQS EQ
  ;

IDS ::= ID ID
  | IDS ID
  ;

origin_var_list ::= ID:func EQ ID:var COMMA origin_var_list:n
    {: RESULT = new OriginFieldList(currLineno(), currColno(), sym(func), sym(var), n); :}
  | ID:func EQ ID:var extra_commas:ec origin_var_list:n
    {: error(ecxleft, "extra commas");RESULT = null;:}
  | ID:func EQS:es ID:var COMMA origin_var_list:n
    {: error(esxleft, "extra equal sign");RESULT = null;:}
  | ID:func EQ IDS:ids COMMA origin_var_list:n
    {: error(idsxleft, "extra ids");RESULT = null;:}
  | ID:func EQ:e COMMA origin_var_list:n
    {: error(exright, "missing id");RESULT = null;:}
  | ID:func EQ ID:var origin_var_list:n
    {: error(varxright, "missing comma");RESULT = null;:}
  | ID:func ID:var COMMA origin_var_list:n
    {: error(funcxright, "missing equal sign");RESULT = null;:}
  | ID:func EQ ID:var
    {: RESULT = new OriginFieldList(currLineno(), currColno(), sym(func), sym(var), null); :}
  ;

/**
 * origin function declaration
 */
origin_func_decl ::=
    ORIGIN type:ret_type ID:fname LPAREN type:arg_type RPAREN 
    {: RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
    | ORIGIN type:ret_type ID:fname extra_lparens:el type:arg_type RPAREN 
    {: error(elxleft, "mismatched parentheses"); 
      RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
    | ORIGIN type:ret_type ID:fname extra_lparens:el type:arg_type extra_rparens 
    {: error(elxleft, "mismatched parentheses"); 
      RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
    | ORIGIN type:ret_type ID:fname LPAREN type:arg_type extra_rparens:er 
    {: error(erxright, "mismatched parentheses"); 
      RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
    | ORIGIN type:ret_type ID:fname LPAREN type:arg_type error:err
    {: error(errxright, "missing parentheses"); 
      RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
    | ORIGIN type:ret_type ID:fname type:arg_type RPAREN 
    {: error(fnamexright, "missing parentheses"); 
      RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
  ;

/**
 * declaration of distinct symbols, (guaranteed objects)
 */
distinct_decl ::=
    DISTINCT refer_name:ty id_or_subid_list:e 
    {: RESULT = new DistinctSymbolDec(currLineno(), currColno(), 
    new NameTy(currLineno(), currColno(), sym(ty)), e); :}
  ;

id_or_subid_list ::= id_or_subid:e {: RESULT = new SymbolArrayList(e, null); :}
  | id_or_subid:e COMMA id_or_subid_list:n
    {: RESULT = new SymbolArrayList(e, n); :}
  | id_or_subid:e id_or_subid_list:n
    {: error(exright, "missing COMMA"); RESULT = null; :}
  | id_or_subid:e extra_commas:ec id_or_subid_list:n
    {: error(ecxleft, "extra COMMA"); RESULT = new SymbolArrayList(e, n); :}
  ;

brackets ::= LBRACKET {:RESULT = null;:}
  | RBRACKET {:RESULT = null;:}
  | brackets LBRACKET {:RESULT = null;:}
  | brackets RBRACKET {:RESULT = null;:}
  ;

bracket_error ::= brackets:b {:error(bxleft, "missing integer literal in brackets"); RESULT = null;:}
  | RBRACKET:rb INT_LITERAL:s LBRACKET {:error(rbxleft, "mismatched brackets"); RESULT = null;:}
  | brackets INT_LITERAL:s {:error(sxright, "missing brackets"); RESULT = null;:}
  | INT_LITERAL:s brackets {:error(sxleft, "missing brackets"); RESULT = null;:}
  | INT_LITERAL:s {:error(sxleft, "missing brackets"); RESULT = null;:}
  | brackets:b LBRACKET INT_LITERAL:s RBRACKET {:error(bxright, "mismatched brackets"); RESULT = null;:}
  | LBRACKET INT_LITERAL:s RBRACKET brackets:b {:error(bxleft, "mismatched brackets"); RESULT = null;:}
  | brackets:b LBRACKET INT_LITERAL:s RBRACKET brackets {:error(bxright, "mismatched brackets"); RESULT = null;:}
  ;

id_or_subid ::= ID:id
    {: RESULT = new SymbolArray(idxleft.getLine(), idxleft.getColumn(), sym(id)); :}
  | ID:id LBRACKET INT_LITERAL:s RBRACKET
    {: RESULT = new SymbolArray(currLineno(), currColno(), sym(id), s.intValue()); :}
  | ID:id bracket_error:be
    {: error(bexleft, "error in sub expression"); :}
  ;

/**
 * declaration of a distribution
 */
distribution_decl ::=
    DISTRIBUTION ID:id EQ refer_name:name
    LPAREN opt_expression_list:e RPAREN 
    {: RESULT = new DistributionDec(currLineno(), currColno(), sym(id),
      new ClassName(currLineno(), currColno(), sym(name)), e); :}
  ;

/* reference to function name or Java class */
refer_name ::= ID:id {: RESULT = id; :}
  | ID:id DOT refer_name:n {: RESULT = id + "." + n; :}
  ;

/**
 * body of random function or number statement
 */
dependency_statement_body ::= EQ expression:e
    {: RESULT = e; :}
  | distribution_expr:e
    {: RESULT = e; :}
  | IF:a expression:e1 THEN dependency_statement_body:e2 elseif_list:e3
    {: RESULT = new IfExpr(currLineno(), currColno(), e1, e2, e3); :}
  | IF:a expression:e1 THEN error elseif_list:e3
    {: error(e3xleft, "invalid expression after then"); :}
  | /* not recommended to add {}, just for compactibility of old syntax */
    LBRACE dependency_statement_body:e RBRACE
    {: RESULT = e; :}
  | LBRACE dependency_statement_body:e SEMI RBRACE
    {: error("extra semicolon inside braces!"); :}
  | IF:a expression:e1 dependency_statement_body:e2 elseif_list:e3
    {: error("missing THEN in dependency statement clause, proceed anyway");
    RESULT = new IfExpr(currLineno(), currColno(), e1, e2, e3); :}
  ;

elseif_list ::=
    ELSE dependency_statement_body:e {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

parameter_decl ::= PARAM type:ty ID:id 
    {: RESULT = new ParameterDec(currLineno(), currColno(), ty, sym(id), null); :}
  | PARAM type:ty ID:id COLON expression:e 
    {: RESULT = new ParameterDec(currLineno(), currColno(), ty, sym(id), e); :}
  ;

/* Represents an expression, which can be either a 0-ary function application, a
 * variable, a  non-0-ary function application, or a built-in constant.
 * (Propagates an error-check from production for specific kinds of terms.)
 *
 * Result is null if the term is invalid.
 */
expression ::= operation_expr:e  {: RESULT = e; :}
  | distribution_expr:e {: RESULT = e; :}
  | literal:e  {: RESULT = e; :}
  | function_call:e {: RESULT = e; :}
  | list_construct_expression:e {: RESULT = e; :}
  | map_construct_expression:e {: RESULT = e; :}
  | quantified_formula:e {: RESULT = e; :}
  | set_expr:e {: RESULT = e; :}
  | number_expr:e {: RESULT = e; :}
  | refer_name:e {: RESULT = new SymbolExpr(currLineno(), currColno(), sym(e)); :}
  ;

literal ::= STRING_LITERAL:e
    {: RESULT = new StringExpr(currLineno(), currColno(), e.intern()); :}
  | CHAR_LITERAL:e
    {: RESULT = new StringExpr(currLineno(), currColno(), e.toString().intern()); :}
  | INT_LITERAL:e
    {: RESULT = new IntExpr(currLineno(), currColno(), e.intValue()); :}
  | DOUBLE_LITERAL:e
    {: RESULT = new DoubleExpr(currLineno(), currColno(), e.doubleValue()); :}
  | BOOLEAN_LITERAL:e
    {: RESULT = new BooleanExpr(currLineno(), currColno(), e.booleanValue()); :}
  | NULL:e
    {: RESULT = new NullExpr(currLineno(), currColno()); :}
  ;

binop ::= PLUS {:RESULT = null;:}
  | MINUS {:RESULT = null;:}
  | MULT {:RESULT = null;:}
  | DIV {:RESULT = null;:}
  | MOD {:RESULT = null;:}
  | POWER {:RESULT = null;:}
  | LT {:RESULT = null;:}
  | GT {:RESULT = null;:}
  | LEQ {:RESULT = null;:}
  | GEQ {:RESULT = null;:}
  | EQEQ {:RESULT = null;:}
  | NEQ {:RESULT = null;:}
  | AND {:RESULT = null;:}
  | OR {:RESULT = null;:}
  | DOUBLERIGHTARROW {:RESULT = null;:}
  ;

operation_expr ::= 
  expression:e1 PLUS expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.PLUS, e2); :}
  | expression:e1 MINUS expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.MINUS, e2); :}
  | expression:e1 MULT expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.MULT, e2); :}
  | expression:e1 DIV expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.DIV, e2); :}
  | expression:e1 MOD expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.MOD, e2); :}
  | expression:e1 POWER expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.POWER, e2); :}
  | expression:e1 LT expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.LT, e2); :}
  | expression:e1 GT expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.GT, e2); :}
  | expression:e1 LEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.LEQ, e2); :}
  | expression:e1 GEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.GEQ, e2); :}
  | expression:e1 EQEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.EQ, e2); :}
  | expression:e1 NEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.NEQ, e2); :}
  | expression:e1 AND expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.AND, e2); :}
  | expression:e1 OR expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.OR, e2); :}
  | expression:e1 DOUBLERIGHTARROW expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.IMPLY, e2); :}
  | expression:e1 LBRACKET expression:e2 RBRACKET
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.SUB, e2); :}
  | expression:e1 binop error:err
  {: error(errxleft, "incorrect or missing righthand expression"); :}
  | error:err binop expression:e2
  {: error(errxleft, "incorrect or missing lefthand expression"); :}
  | array_type_or_sub:e1 expression:e2 RBRACKET
    {: RESULT = new OpExpr(currLineno(), currColno(), 
      new SymbolExpr(currLineno(), currColno(), sym(e1)), OpExpr.SUB, e2); :}
  | unary_operation_expr:e {: RESULT = e; :}
  | LPAREN:lp unary_operation_expr:e error:err {: error(errxleft, "mismatched parentheses"); RESULT = null;:}
  | extra_lparens:lp unary_operation_expr:e error:err {: error(errxleft, "mismatched parentheses"); RESULT = null;:}
  | unary_operation_expr:e RPAREN error:err {: error(errxleft, "mismatched parentheses"); RESULT = null;:}
  ;

unary_operation_expr ::=
    MINUS expression:e
    {: RESULT = new OpExpr(currLineno(), currColno(), new IntExpr(currLineno(), currColno(), 0), OpExpr.NOT, e); :}
  | NOT expression:e
    {: RESULT = new OpExpr(currLineno(), currColno(), null, OpExpr.NOT, e); :}
  | AT:a expression:e
    {: RESULT = new OpExpr(currLineno(), currColno(), null, OpExpr.AT, e); :}
  | LPAREN expression:e RPAREN
    {: RESULT = e; :}
  | LPAREN expression:e error:err
    {: error(errxleft, "mismatched parentheses"); RESULT = e; :}
  ;

quantified_formula ::= FORALL type:ty ID:id expression:e
    {: RESULT = new QuantifiedFormulaExpr(currLineno(), currColno(),
    QuantifiedFormulaExpr.FORALL, ty, sym(id), e); :}
  | EXISTS type:ty ID:id expression:e
    {: RESULT = new QuantifiedFormulaExpr(currLineno(), currColno(),
    QuantifiedFormulaExpr.EXISTS, ty, sym(id), e); :}
  | FORALL error:err
    {: error(errxleft, "error in for all formula"); RESULT = null; :}
  | EXISTS error:err
    {: error(errxleft, "error in exists formula"); RESULT = null; :}
  | FORALL type:ty expression:e
    {: error(tyxright, "missing id in for all statement"); RESULT = null;:}
  | FORALL:fa ID:id expression:e
    {: error(faxright, "missing type in for all statement"); RESULT = null;:}
  | FORALL type:ty ID:id error:err
    {: error(errxleft, "error in for all expression"); RESULT = null;:}
  | EXISTS type:ty expression:e
    {: error(tyxright, "missing id in exists statement"); RESULT = null;:}
  | EXISTS:ex ID:id expression:e
    {: error(exxright, "missing type in exists statement"); RESULT = null;:}
  | EXISTS type:ty ID:id error:err
    {: error(errxleft, "error in exists expression"); RESULT = null;:}
  ;

function_call ::= refer_name:id LPAREN opt_expression_list:e RPAREN
    {: RESULT = new FuncCallExpr(currLineno(), currColno(), sym(id), e); :}
  ;

distribution_expr ::= DISTRIB refer_name:name LPAREN opt_expression_list:e RPAREN
    {: RESULT = new DistributionExpr(currLineno(), currColno(), sym(name), e); :}
  ;

opt_expression_list ::= expression_list:e {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

expression_list ::= expression:e COMMA expression_list:elst
    {: RESULT = new ExprList(e, elst); :}
  | expression:e
    {: RESULT = new ExprList(e, null); :}
  ;

list_construct_expression ::= LBRACKET opt_expression_list:e RBRACKET
    {: RESULT = new ListInitExpr(currLineno(), currColno(), e); :}
  | LBRACKET semi_colon_separated_expression_list:e RBRACKET
    {: RESULT = new ListInitExpr(currLineno(), currColno(), e); :}
  ;

SEMIS ::= SEMI SEMI
  | SEMIS SEMI
  ;

semi_colon_separated_expression_list ::=
    expression_list:e SEMI semi_colon_separated_expression_list:elst
    {: RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), elst); :}
  | expression_list:e SEMIS:s semi_colon_separated_expression_list:elst
    {: error(sxleft, "extra semicolon"); RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), elst); :}
  | expression_list:e SEMI expression_list:e2
    {: RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), new ExprList(new ListInitExpr(e2xleft.getLine(), e2), null)); :}
  | expression_list:e SEMIS:s expression_list:e2
    {: error(sxleft, "extra semicolon"); RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), new ExprList(new ListInitExpr(e2xleft.getLine(), e2), null)); :}
  | expression_list:e semi_colon_separated_expression_list:elst
    {: error(exright, "missing semicolon"); RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), elst); :}
  | expression_list:e expression_list:e2
    {: error(exright, "missing semicolon"); RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), new ExprList(new ListInitExpr(e2xleft.getLine(), e2), null)); :}
  ;

map_construct_expression ::= LBRACE expression_pair_list:e RBRACE
    {: RESULT = new MapInitExpr(currLineno(), currColno(), e); :}
  ;

// to avoid conflict with Imply expression
expression_pair_list ::=
    expression:e1 RIGHTARROW expression:e2 COMMA expression_pair_list:e3
    {: RESULT = new ExprTupleList(e1, e2, e3); :}
  | expression:e1 RIGHTARROW expression:e2 
    {: RESULT = new ExprTupleList(e1, e2, null); :}
  ;
  
number_expr ::= NUMSIGN set_expr:e
    {: RESULT = new NumberExpr(currLineno(), currColno(), e); :}
  | NUMSIGN type:ty
    {: RESULT = new NumberExpr(currLineno(), currColno(), new ImplicitSetExpr(currLineno(), currColno(), ty, null, null)); :}
  | NUMSIGN error:err
    {: error(errxleft, "expecting number expression here. # should be followed by a type or a set"); :}
  ;

set_expr ::= explicit_set:e {: RESULT = e; :}
  | implicit_set:e {: RESULT = e; :}
  | tuple_set:e {: RESULT = e; :}
  ;

explicit_set ::= LBRACE opt_expression_list:e RBRACE
    {: RESULT = new ExplicitSetExpr(currLineno(), currColno(), e); :}
  ;

implicit_set ::= LBRACE type:ty ID:id COLON expression:e RBRACE
    {: RESULT = new ImplicitSetExpr(currLineno(), currColno(), ty, sym(id), e); :}
  | LBRACE type:ty ID:id RBRACE
    {: RESULT = new ImplicitSetExpr(currLineno(), currColno(), ty, sym(id), null); :}
  ;

tuple_set ::= LBRACE expression_list:elst FOR type_var_lst:vars COLON expression:e RBRACE
    {: RESULT = new TupleSetExpr(currLineno(), currColno(), elst, vars, e); :}
  | LBRACE expression_list:elst FOR type_var_lst:vars RBRACE
    {: RESULT = new TupleSetExpr(currLineno(), currColno(), elst, vars, null); :}
  ;

///no implementation for PARFACTOR


/* Represents an evidence statement, which can be:
 *
 *    * a symbol evidence statement, listing observed objects of the specified
 *    type subject to certain constraints
 *        (Semantic checks:
 *        - whether the type for which the evidence is presented has been
 *      declared;
 *        - whether the formula is valid (error-check is propagated from
 *      the productions for various kinds of formulas).);
 *    * a value evidence statement, stating the value of the specified
 *    function on the specified tuple of arguments
 *        (Semantic checks:
 *        - whether the numbers of the function's parameters and arguments
 *      passed to it match;
 *            - whether the function has been declared.).
 */
evidence_stmt ::= OBS evidence:e  {: RESULT = e; :};

evidence ::=
   symbol_evidence:e {: RESULT = e; :}
   | value_evidence:e {: RESULT = e; :}
//  | tuple_evidence:e {: RESULT = e; :} //not implemented yet
  ;

/* valid evidence format include (will be checked in semantic checking)
 *   - general form: random expression = fixed expression
 *   - symbol evidence: implicit_set = explicit_set of ids
 *   - number_evidence: # implicit_set = int constant
 */
value_evidence ::=
    expression:e1 EQ expression:e2
    {: RESULT = new ValueEvidence(currLineno(), currColno(), e1, e2); :}
    | error:err EQ expression:e2
    {:error(errxleft, "incorrect first expression"); RESULT = null;:}
    | expression:e1 EQ error:err
    {:error(errxleft, "incorrect second expression"); RESULT = null;:}
  ;

symbol_evidence ::=
    implicit_set:e1 EQ explicit_set:e2
    {: RESULT = new SymbolEvidence(currLineno(), currColno(), e1, e2); :}
    | error EQ error
    {:error("error in first and second set"); RESULT = null;:}
  ;

query_stmt ::= QUERY  query:q 
    {: RESULT = q; :}
    | QUERY error 
    {: error("invalid query"); RESULT = null;:}
  ;

query ::= expression:e {: RESULT = new QueryStmt(currLineno(), currColno(), e); :}
  ;
