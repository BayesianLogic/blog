/*
 * Copyright (c) 2005, 2006, Regents of the University of California
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.  
 *
 * * Neither the name of the University of California, Berkeley nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior 
 *   written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package blog.parse;
import java_cup.runtime.*;
import blog.absyn.*;


action code {: 

  static blog.symbol.Symbol sym(String s) {
	         return blog.symbol.Symbol.symbol(s);
  }

    LocationInFile getCurLocation() {
        return new LocationInFile
            (((ScannerWithLocInfo)parser.getScanner()).getCurFilename(),
             ((ScannerWithLocInfo)parser.getScanner()).getCurLineNum());
    }
   
    int curr_lineno() {
	return ((ScannerWithLocInfo)parser.getScanner()).getCurLineNum();
    }

/*
    void semantic_error( String message ){
         System.err.println("\n" + curr_filename( ) + ":" + curr_lineno( ) 
                            + " Semantic error: " + message);
	 parser.omerrs++;
    }
*/

    void warning( String message ){
         System.err.println("\n" + curr_filename( ) + ":" + curr_lineno( ) 
                            + " Warning: " + message);
    }

    String curr_filename() {
	  return ((ScannerWithLocInfo)parser.getScanner()).getCurFilename();
    }
   
:} 


parser code {:
  Absyn parseResult; //variable to store the final parsing result
  
  public Absyn getParseResult() {
    return parseResult;
  }
:}

init with {:

:}

/* Terminal declarations; a few have types for associated lexemes.  The
 * token ERROR is never used in the parser; thus, it is a parse error when
 * the lexer returns it. For the terminals' interpretations, consult with
 * BLOGLexer.lex.  
 */
terminal FACTOR, PARFACTOR, FOR; //not implemented yet
terminal ERROR;
terminal ELSE, ELSEIF, IF, THEN;
terminal TYPE, RANDOM, FIXED, ORIGIN, DISTINCT, 
        QUERY, OBS, PARAM, MAP, DISTRIBUTION;
terminal EXISTS, FORALL;
terminal NULL;
terminal java.lang.Number INT_LITERAL, DOUBLE_LITERAL, TIME_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHAR_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String ID; 
terminal PLUS, MINUS, MULT, DIV, MOD; 
terminal LT, GT, LEQ, GEQ; // relational_expression
terminal EQEQ, NEQ;
terminal EQ;
terminal DISTRIB;
terminal NOT, AND, OR; 
terminal COMMA, SEMI, COLON, DOT, NUMSIGN, RIGHTARROW;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;

nonterminal program;
nonterminal StmtList opt_statement_lst, statement_lst;
nonterminal Stmt statement, declaration_stmt, type_decl, fixed_func_decl,
  rand_func_decl, number_stmt, origin_func_decl,
  distinct_decl, distribution_decl, parameter_decl, 
  evidence_stmt, query_stmt;
nonterminal Stmt evidence, value_evidence, query;
nonterminal Expr expression, literal, operation_expr, unary_operation_expr, 
  quantified_formula, 
  function_call, list_construct_expression,  
  map_construct_expression, number_expr, elseif_list;
nonterminal Expr dependency_statement_body; 
nonterminal SetExpr set_expr, explicit_set, implicit_set;
nonterminal ExprList semi_colon_separated_expression_list, 
  opt_expression_list, expression_list;
nonterminal ExprTupleList expression_pair_list;
nonterminal Ty type, array_type, map_type, name_type;
nonterminal Integer dims; 
nonterminal FieldList opt_parenthesized_type_lst, type_lst; 
nonterminal FieldList opt_parenthesized_type_var_lst, type_var_lst;
nonterminal OriginFieldList opt_parenthesized_origin_var_list, 
  origin_var_list;
nonterminal SymbolArray id_or_subid;
nonterminal SymbolArrayList id_or_subid_list;
nonterminal String class_name;


/*
 * Precedence declarations.  The later the precedence declaration, the 
 * higher the precedence.  
 */
precedence left ELSE;
precedence nonassoc EQ, DISTRIB;
precedence right RIGHTARROW;
precedence left AND, OR;
precedence left NOT;
precedence nonassoc LT, GT, LEQ, GEQ, EQEQ, NEQ; 
precedence left PLUS, MINUS; 
precedence left MULT, DIV, MOD; 
precedence left LBRACKET;


/* Grammar *******************************************************************/

start with program;


/* The start nonterminal */
program ::= opt_statement_lst : e {: parser.parseResult = e;  :}
                ;

/* Represents a possibly-empty list of statements. */
opt_statement_lst ::= /* EMPTY */ {: RESULT = null; :}
                | statement_lst : e {: RESULT = e; :}
                ;

/* Represents a non-empty list of statements terminated by semicolons. */
statement_lst ::= statement:e statement_lst:slst {: RESULT = new StmtList(e, slst); :} 
		| statement:e {: RESULT = new StmtList(e, null); :} 
		| error
		{: System.err.println( 
			"Possible cause: forgotten semicolon" ); 
			RESULT = null; :}
		;

/* A statement can be a declaration, an observation (assertion of some 
 * evidence), or a query.
 */
statement ::= declaration_stmt : e {: RESULT = e; :}
            | evidence_stmt : e {: RESULT = e; :}
            | query_stmt : e {: RESULT = e; :}
            ;

/* Represents a declaration, which can be:
 *    * a type declaration;
 *    * a paramemeter declaration;
 *    * a random function or generating function declaration
 *        (Semantic checks:
 *            - whether the return type is a declared type;
 *            - whether the argument types have been declared (an error-check 
 *		  propagated from the type_lst production.);
 *    * a random function definition
 *    * a non-random function (or constant) declaration
 *    * a non-random function (or constant) definition, specifying the 
 *      interpretation of the function 
 *    * a random function dependency statement description
 *        (Semantic checks:
 *	      - whether the numbers of actual and declared parameters match;
 *            - whether the function by this name has been declared.);
 *    * a guaranteed object declaration
 *        (Semantic checks:
 *            - whether the type has been declared.);
 *    * a POP number statement description
 *        (Semantic checks:
 *            - whether the numbers of generating functions and parameters 
 *                match;
 *            - whether the generating functions have been declared (an 
 *                error-check propagated from the function_lst production);
 *            - whether each generating function takes exactly one parameter (an
 *                error-check propagated from the function_lst production);
 *            - whether the only parameter of each generating function is of the
 *                type being generated.).
 *    * a parfactor statement // not used in current blog
 */   
declaration_stmt ::= 
    type_decl:e {: RESULT = e; :}
  | fixed_func_decl:e {: RESULT = e; :}
  | rand_func_decl:e {: RESULT = e; :}
  | origin_func_decl : e {: RESULT = e; :}
//  | dep_stmt : e {: RESULT = e; :}
  | number_stmt : e {: RESULT = e; :}
  | distinct_decl : e {: RESULT = e; :}
  | parameter_decl : e {: RESULT = e; :}
  | distribution_decl :e {: RESULT = e; :}
/*  | parfactor : e {: RESULT = e; :}  */
  ;
		   
type_decl ::= TYPE ID:typename SEMI
    {: RESULT = new TypeDec(typenameleft, sym(typename)); :} 
  ;


/* 
 * Represents a type that is built in or has already been declared.  
 * can also be an array  
 */
type ::= name_type:e {: RESULT = e; :}
  | array_type : at {: RESULT = at; :}
  | map_type:e {: RESULT = e; :}
  ;
  
name_type ::= ID:typename 
    {: RESULT = new NameTy(typenameleft, sym(typename)); :}
  ;
       
array_type ::= ID : typename  dims : d
    /* only allow nametype as array */
    {: RESULT = new ArrayTy(typenameleft, 
        new NameTy(typenameleft, sym(typename)), d.intValue()); :}
  ;

dims ::= LBRACKET RBRACKET {: RESULT = new Integer(1); :}
  | LBRACKET RBRACKET dims : d {: RESULT = new Integer(d.intValue() + 1); :}
  ;
  
map_type ::= MAP LT type:t1 COMMA type:t2 GT 
    {: RESULT = new MapTy(t1left, t1, t2); :}
  ;

/* A possibly empty list of IDs denoting type names. */
opt_parenthesized_type_lst ::= /* EMPTY */
	    {: RESULT = null; :}
	    | LPAREN RPAREN          
	    {: RESULT = null; :}
	    | LPAREN type_lst:tl RPAREN
	    {: RESULT = tl; :}
	    ;

type_lst ::= type:ty COMMA type_lst:tl  
	  {: RESULT = new FieldList(tyleft, null, ty, tl); :}    
	| type:ty
	  {: RESULT = new FieldList(tyleft, null, ty, null); :}
	;

/* Represents a list of IDs denoting type names. */  
opt_parenthesized_type_var_lst ::= /* EMPTY */
    {: RESULT = null; :}
  | LPAREN RPAREN          
    {: RESULT = null; :}
  | LPAREN type_var_lst:tl RPAREN
    {: RESULT = tl; :}
  ;

type_var_lst ::= type:ty ID:id COMMA type_var_lst:tl  
    {: RESULT = new FieldList(tyleft, sym(id), ty, tl); :}    
  | type:ty ID:id
    {: RESULT = new FieldList(tyleft, sym(id), ty, null); :}
  ;


/* A nonrandom function declaration may declare a nonrandom constant or 
 * a non-random function.  The distinction is whether there is a 
 * parenthesized list of arguments after the function/constant name.  
 */
fixed_func_decl ::= 
    FIXED type:ret_type ID:fname opt_parenthesized_type_var_lst:otl 
    EQ expression:ex SEMI
    {: RESULT = new FixedFuncDec(fnameleft, sym(fname), otl, ret_type, ex); :}
  ;

/**
 * random function declaration
 * including dependency statement
 */
rand_func_decl ::= 
    RANDOM type:ret_type ID:fname opt_parenthesized_type_var_lst:otl
    dependency_statement_body:body SEMI
    {: RESULT = new RandomFuncDec(fnameleft, sym(fname), otl, ret_type, body); :}
  ;

/**
 * number statement 
 */ 
number_stmt ::=
    NUMSIGN name_type:ty opt_parenthesized_origin_var_list:otl     
	dependency_statement_body:body SEMI
    {: RESULT = new NumberDec(tyleft, ty, otl, body); :}
  ;

opt_parenthesized_origin_var_list ::= LPAREN origin_var_list:e RPAREN
    {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

origin_var_list ::= ID:func EQ ID:var COMMA origin_var_list:n
    {: RESULT = new OriginFieldList(funcleft, sym(func), sym(var), n); :} 
  | ID:func EQ ID:var
    {: RESULT = new OriginFieldList(funcleft, sym(func), sym(var), null); :}
  ;
  
/**
 * origin function declaration
 */
origin_func_decl ::= 
    ORIGIN type:ret_type ID:fname LPAREN type:arg_type RPAREN SEMI
    {: RESULT = new OriginFuncDec(fnameleft, sym(fname), 
      new FieldList(arg_type.pos, null, arg_type, null), ret_type); :}
  ;

/**
 * declaration of distinct symbols, (guaranteed objects)
 */
distinct_decl ::= 
    DISTINCT name_type:ty id_or_subid_list:e SEMI
    {: RESULT = new DistinctSymbolDec(tyleft, ty, e); :}
  ;  
 
id_or_subid_list ::= id_or_subid:e {: RESULT = new SymbolArrayList(eleft, e, null); :}
  | id_or_subid:e COMMA id_or_subid_list:n
    {: RESULT = new SymbolArrayList(eleft, e, n); :}
  ;
  
id_or_subid ::= ID:id
    {: RESULT = new SymbolArray(idleft, sym(id)); :}
  | ID:id LBRACKET INT_LITERAL:s RBRACKET
    {: RESULT = new SymbolArray(idleft, sym(id), s.intValue()); :}
  ;

/**
 * declaration of a distribution
 */
distribution_decl ::= 
    DISTRIBUTION ID:id EQ class_name:name 
    LPAREN opt_expression_list:e RPAREN SEMI
    {: RESULT = new DistributionDec(idleft, sym(id), 
      new ClassName(nameleft, sym(name)), e); :}
  ;
  

/* reference to Java class */
class_name ::= ID:id {: RESULT = id; :}
  | ID:id DOT class_name:n {: RESULT = id + "." + n; :}
  ;

/**
 * body of random function or number statement
 */
dependency_statement_body ::= EQ expression:e
    {: RESULT = e; :}
  | DISTRIB class_name:name LPAREN opt_expression_list:e RPAREN
    {: RESULT = new DistributionExpr(nameleft, sym(name), e); :}
  | IF:a expression:e1 THEN dependency_statement_body:e2 elseif_list:e3
    {: RESULT = new IfExpr(aleft, e1, e2, e3); :} 
  | /* not recommended to add {}, just for compactibility of old syntax */
    LBRACE dependency_statement_body:e RBRACE
    {: RESULT = e; :}  
  ;
	
elseif_list ::= 
//    ELSEIF:eif expression:e1 THEN dependency_statement_body:e2 elseif_list:e3
//    {: RESULT = new IfExpr(eifleft, e1, e2, e3); :} | 
    ELSE dependency_statement_body:e
    {: RESULT = e; :}
  | {: RESULT = null; :}
  ;	

parameter_decl ::= PARAM type:ty ID:id SEMI
    {: RESULT = new ParameterDec(tyleft, ty, sym(id), null); :}
  | PARAM type:ty ID:id COLON expression:e SEMI
    {: RESULT = new ParameterDec(tyleft, ty, sym(id), e); :}
  ;

/* Represents a term, which can be either a 0-ary function application, a 
 * variable, a  non-0-ary function application, or a built-in constant.
 * (Propagates an error-check from production for specific kinds of terms.) 
 * 
 * Result is null if the term is invalid.    
 */
 
expression ::= operation_expr:e  {: RESULT = e; :}
  | literal:e  {: RESULT = e; :}
  | function_call:e {: RESULT = e; :}
  | list_construct_expression:e {: RESULT = e; :}
  | map_construct_expression:e {: RESULT = e; :}
  | quantified_formula:e {: RESULT = e; :}
  | set_expr:e {: RESULT = e; :}  
  | number_expr:e {: RESULT = e; :}    
  ;
    
literal ::= STRING_LITERAL:e 
    {: RESULT = new StringExpr(eleft, e.intern()); :}
  | CHAR_LITERAL:e
    {: RESULT = new StringExpr(eleft, e.toString().intern()); :}
  | INT_LITERAL:e
    {: RESULT = new IntExpr(eleft, e.intValue()); :}
  | DOUBLE_LITERAL:e
    {: RESULT = new DoubleExpr(eleft, e.doubleValue()); :}
  | TIME_LITERAL:e
    {: RESULT = new TimeExpr(eleft, e.intValue()); :}
  | BOOLEAN_LITERAL:e
    {: RESULT = new BooleanExpr(eleft, e.booleanValue()); :}
  | NULL:e
    {: RESULT = new NullExpr(eleft); :}
  ;

    
operation_expr ::= expression:e1 PLUS expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.PLUS, e2); :}
  | expression:e1 MINUS expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.MINUS, e2); :}
  | expression:e1 MULT expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.MULT, e2); :}
  | expression:e1 DIV expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.DIV, e2); :}
  | expression:e1 MOD expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.MOD, e2); :}
  | expression:e1 LT expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.LT, e2); :}
  | expression:e1 GT expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.GT, e2); :}
  | expression:e1 LEQ expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.LEQ, e2); :}
  | expression:e1 GEQ expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.GEQ, e2); :}
  | expression:e1 EQEQ expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.EQ, e2); :} 
  | expression:e1 NEQ expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.NEQ, e2); :}
  | expression:e1 AND expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.AND, e2); :}
  | expression:e1 OR expression:e2 
    {: RESULT = new OpExpr(e1left, e1, OpExpr.OR, e2); :}
  | expression:e1 LBRACKET expression:e2 RBRACKET
    {: RESULT = new OpExpr(e1left, e1, OpExpr.SUB, e2); :}
  | unary_operation_expr:e {: RESULT = e; :}
  ;

unary_operation_expr ::= 
    MINUS expression:e
    {: RESULT = new OpExpr(eleft, new IntExpr(eleft, 0), OpExpr.NOT, e); :}
  | NOT expression:e
    {: RESULT = new OpExpr(eleft, null, OpExpr.NOT, e); :}
  ;


quantified_formula ::= FORALL type:ty ID:id expression:e
    {: RESULT = new QuantifiedFormulaExpr(tyleft, 
    QuantifiedFormulaExpr.FORALL, ty, sym(id), e); :}
  | EXISTS type:ty ID:id expression:e
    {: RESULT = new QuantifiedFormulaExpr(tyleft, 
    QuantifiedFormulaExpr.EXISTS, ty, sym(id), e); :}
  ;

function_call ::= ID:id LPAREN opt_expression_list:e RPAREN
    {: RESULT = new FuncCallExpr(idleft, sym(id), e); :}
  | ID:id 
    {: RESULT = new FuncCallExpr(idleft, sym(id), null); :}
  ;

opt_expression_list ::= expression_list:e {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

expression_list ::= expression:e COMMA expression_list:elst
    {: RESULT = new ExprList(e, elst); :}
  | expression:e
    {: RESULT = new ExprList(e, null); :}
  ;
  
list_construct_expression ::= LBRACKET opt_expression_list:e RBRACKET
    {: RESULT = new ListInitExpr(eleft, e); :}
  | LBRACKET semi_colon_separated_expression_list:e RBRACKET
    {: RESULT = new ListInitExpr(eleft, e); :}
  ;

semi_colon_separated_expression_list ::= 
    expression_list:e SEMI semi_colon_separated_expression_list:elst
    {: RESULT = new ExprList(new ListInitExpr(eleft, e), elst); :}
  | expression_list:e SEMI expression_list:e2
    {: RESULT = new ExprList(new ListInitExpr(eleft, e), new ExprList(new ListInitExpr(e2left, e2), null)); :}
  ;

map_construct_expression ::= LBRACE expression_pair_list:e RBRACE
    {: RESULT = new MapInitExpr(eleft, e); :}
  ;
  
expression_pair_list ::= 
    expression:e1 RIGHTARROW expression:e2 COMMA expression_pair_list:e3
    {: RESULT = new ExprTupleList(e1, e2, e3); :}
  | expression:e1 RIGHTARROW expression:e2
    {: RESULT = new ExprTupleList(e1, e2, null); :}
  ;

number_expr ::= NUMSIGN set_expr:e
    {: RESULT = new NumberExpr(eleft, e); :}
  | NUMSIGN type:ty
    {: RESULT = new NumberExpr(tyleft, new ImplicitSetExpr(tyleft, ty, null, null)); :}
  ;


set_expr ::= explicit_set:e {: RESULT = e; :}
  | implicit_set:e {: RESULT = e; :}
  ;
  
explicit_set ::= LBRACE opt_expression_list:e RBRACE
    {: RESULT = new ExplicitSetExpr(eleft, e); :}
  ;
  
implicit_set ::= LBRACE type:ty ID:id COLON expression:e RBRACE
    {: RESULT = new ImplicitSetExpr(tyleft, ty, sym(id), e); :}
  ;
  
  
///no implementation for PARFACTOR


/* Represents an evidence statement, which can be:
 *    
 *    * a symbol evidence statement, listing observed objects of the specified 
 *	  type subject to certain constraints 
 *        (Semantic checks:
 *	      - whether the type for which the evidence is presented has been 
 *		  declared;
 *	      - whether the formula is valid (error-check is propagated from 
 *		  the productions for various kinds of formulas).);      
 *    * a value evidence statement, stating the value of the specified 
 *	  function on the specified tuple of arguments
 *        (Semantic checks:
 *	      - whether the numbers of the function's parameters and arguments 
 *		  passed to it match;
 *            - whether the function has been declared.).
 */ 
evidence_stmt ::= OBS evidence:e SEMI {: RESULT = e; :}
  ;

evidence ::= 
//    symbol_evidence:e {: RESULT = e; :} |//covered by value_evidence
//    number_evidence:e {: RESULT = e; :} |//covered by value_evidence
   value_evidence:e {: RESULT = e; :}
//  | tuple_evidence:e {: RESULT = e; :} //not implemented yet
  ;

/*
symbol_evidence ::= 
    implicit_set:e1 EQ explicit_set:e2 
    {: RESULT = new SymbolEvidence(e1left, e1, e2); :}
  ;

number_evidence ::= 
    NUMSIGN implicit_set:e1 EQ INT_LITERAL:s 
    {: RESULT = new NumberEvidence(e1left, e1, s.intValue()); :}
  ;
*/

value_evidence ::=
    expression:e1 EQ expression:e2 
    {: RESULT = new ValueEvidence(e1left, e1, e2); :}
  ;
  
query_stmt ::= QUERY  query:q SEMI
    {: RESULT = q; :}
  ;
  
query ::= expression:e {: RESULT = new Query(eleft, e); :}
  ;
