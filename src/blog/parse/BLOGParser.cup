/*
 * Copyright (c) 2005, 2012, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * * Neither the name of the University of California, Berkeley nor
 *   the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior
 *   written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY:w, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * use JFlex
 * @author leili
 * @author bramsundar
 * @date 2012-07
 */

package blog.parse;
import java_cup.runtime.*;
import blog.absyn.*;


action code {:

  static blog.symbol.Symbol sym(String s) {
	         return blog.symbol.Symbol.symbol(s);
  }

    LocationInFile getCurLocation() {
        return new LocationInFile
            (((ScannerWithLocInfo)parser.getScanner()).getCurFilename(),
             ((ScannerWithLocInfo)parser.getScanner()).getCurLineNum());
    }

    int currLineno() {
	return ((ScannerWithLocInfo)parser.getScanner()).getCurLineNum();
    }


    int currColno() {
	return ((ScannerWithLocInfo)parser.getScanner()).getCurColNum();
    }

/* //TO-DO
    void semantic_error( String message ){
         System.err.println("\n" + curr_filename( ) + ":" + curr_lineno( )
                            + " Semantic error: " + message);
	 parser.omerrs++;
    }
*/
  void error(String msg) {
    parser.errorMsg.error(currLineno(), currColno(), msg);
  }

    void warning( String message ){
         System.err.println("\n" + curr_filename( ) + ":" + currLineno( )
                            + " Warning: " + message);
    }

    String curr_filename() {
	  return ((ScannerWithLocInfo)parser.getScanner()).getCurFilename();
    }

:}


parser code {:
  Absyn parseResult; //variable to store the final parsing result
  blog.msg.ErrorMsg errorMsg; //for error

  public Absyn getParseResult() {
    return parseResult;
  }

  public BLOGParser(Scanner s, blog.msg.ErrorMsg msg) {
    this(s);
    errorMsg = msg;
  }

:}

init with {:

:}

/* Terminal declarations; a few have types for associated lexemes.  The
 * token ERROR is never used in the parser; thus, it is a parse error when
 * the lexer returns it. For the terminals' interpretations, consult with
 * BLOGLexer.lex.
 */
terminal ELSE, IF, THEN;
terminal TYPE, RANDOM, FIXED, ORIGIN, DISTINCT,
        QUERY, OBS, PARAM, LIST, MAP, DISTRIBUTION;
terminal EXISTS, FORALL;
terminal FOR;
terminal NULL;
terminal java.lang.Number INT_LITERAL, DOUBLE_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHAR_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String ID;
terminal PARFACTOR, FACTOR; // Not Yet Implemented
terminal ERROR, ELSEIF; // Not Yet Implemented
terminal AT; // time operator
terminal PLUS, MINUS, MULT, DIV, MOD, POWER; //arithmetic operator
terminal LT, GT, LEQ, GEQ; // relational_expression
terminal EQEQ, NEQ; // equality compare
terminal EQ; // assignment operator
terminal DISTRIB;
terminal NOT, AND, OR, DOUBLERIGHTARROW; // logical operator
terminal COMMA, SEMI, COLON, DOT, NUMSIGN, RIGHTARROW; //seperators
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET; // paired seperators

nonterminal program;
nonterminal StmtList opt_statement_lst, statement_lst;
nonterminal Stmt statement, declaration_stmt, type_decl, fixed_func_decl,
  rand_func_decl, number_stmt, origin_func_decl,
  distinct_decl, distribution_decl, parameter_decl,
  evidence_stmt, query_stmt;
nonterminal Stmt evidence, value_evidence, symbol_evidence, query;
nonterminal Expr expression, literal, operation_expr, unary_operation_expr,
  quantified_formula, distribution_expr,
  function_call, list_construct_expression, symbol_expr,
  map_construct_expression, number_expr, elseif_list;
nonterminal Expr dependency_statement_body;
nonterminal SetExpr set_expr;
nonterminal ExplicitSetExpr explicit_set;
nonterminal ImplicitSetExpr implicit_set;
nonterminal TupleSetExpr tuple_set;
nonterminal ExprList semi_colon_separated_expression_list,
  opt_expression_list, expression_list;
nonterminal ExprTupleList expression_pair_list;
nonterminal Ty type, array_type, list_type, map_type, name_type;
nonterminal Integer dims;
//nonterminal FieldList opt_parenthesized_type_lst, type_lst // Not Used
nonterminal FieldList opt_parenthesized_type_var_lst, type_var_lst;
nonterminal OriginFieldList opt_parenthesized_origin_var_list,
  origin_var_list;
nonterminal SymbolArray id_or_subid;
nonterminal SymbolArrayList id_or_subid_list;
nonterminal String class_name;


/*
 * Precedence declarations.  The later the precedence declaration, the
 * higher the precedence.
 */
precedence left ELSE;
precedence nonassoc EQ, DISTRIB;
precedence right RIGHTARROW;
precedence left DOUBLERIGHTARROW;
precedence left AND, OR;
precedence left NOT;
precedence nonassoc LT, GT, LEQ, GEQ, EQEQ, NEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, POWER;
precedence left LBRACKET;


/* Grammar *******************************************************************/

start with program;


/* The start nonterminal */
program ::= opt_statement_lst : e {: parser.parseResult = e;  :}
                ;

/* Represents a possibly-empty list of statements. */
opt_statement_lst ::= /* EMPTY */ {: RESULT = null; :}
                | statement_lst : e {: RESULT = e; :}
                ;

/* Represents a non-empty list of statements terminated by semicolons. */
statement_lst ::= statement:e statement_lst:slst
    {: if (e==null) RESULT = slst;
       else RESULT = new StmtList(e, slst);
    :}
  | statement:e {: RESULT = new StmtList(e, null); :}
  | error
	{: System.err.println(
		"Possible cause: forgotten semicolon" );
		RESULT = null; :}
;

/* A statement can be a declaration, an observation (assertion of some
 * evidence), or a query.
 */
statement ::= declaration_stmt : e {: RESULT = e; :}
            | evidence_stmt : e {: RESULT = e; :}
            | query_stmt : e {: RESULT = e; :}
            | error SEMI
            {: error("unmatched statement, or possible missing semicolon");
              RESULT = null; :}
            ;

/* Represents a declaration, which can be:
 *    * a type declaration;
 *    * a parameter declaration;
 *    * a random function or generating function declaration
 *        (Semantic checks:
 *            - whether the return type is a declared type;
 *            - whether the argument types have been declared (an error-check
 *		  propagated from the type_lst production.);
 *    * a random function definition
 *    * a non-random function (or constant) declaration
 *    * a non-random function (or constant) definition, specifying the
 *      interpretation of the function
 *    * a random function dependency statement description
 *        (Semantic checks:
 *	      - whether the numbers of actual and declared parameters match;
 *            - whether the function by this name has been declared.);
 *    * a guaranteed object declaration
 *        (Semantic checks:
 *            - whether the type has been declared.);
 *    * a POP number statement description
 *        (Semantic checks:
 *            - whether the numbers of generating functions and parameters
 *                match;
 *            - whether the generating functions have been declared (an
 *                error-check propagated from the function_lst production);
 *            - whether each generating function takes exactly one parameter (an
 *                error-check propagated from the function_lst production);
 *            - whether the only parameter of each generating function is of the
 *                type being generated.).
 *    * a parfactor statement // not used in current blog
 */
declaration_stmt ::=
    type_decl:e {: RESULT = e; :}
  | fixed_func_decl:e {: RESULT = e; :}
  | rand_func_decl:e {: RESULT = e; :}
  | origin_func_decl : e {: RESULT = e; :}
//  | dep_stmt : e {: RESULT = e; :}
  | number_stmt : e {: RESULT = e; :}
  | distinct_decl : e {: RESULT = e; :}
  | parameter_decl : e {: RESULT = e; :}
  | distribution_decl :e {: RESULT = e; :}
/*  | parfactor : e {: RESULT = e; :}  */
  ;

type_decl ::= TYPE ID:typename SEMI
    {: RESULT = new TypeDec(currLineno(), currColno(), sym(typename)); :}
  ;


/*
 * Represents a type that is built in or has already been declared.
 * can also be an array
 */
type ::= name_type:e {: RESULT = e; :}
  | list_type:e {: RESULT = e; :}
  | array_type : at {: RESULT = at; :}
  | map_type:e {: RESULT = e; :}
  ;

name_type ::= ID:typename
    {: RESULT = new NameTy(currLineno(), currColno(), sym(typename)); :}
  ;

list_type ::= LIST LT ID:typename GT
    /* only allow nametype as list */
    {: RESULT = new ListTy(currLineno(), currColno(),
        new NameTy(currLineno(), currColno(), sym(typename))); :}
  ;

array_type ::= ID : typename  dims : d
    /* only allow nametype as array */
    {: RESULT = new ArrayTy(currLineno(), currColno(),
        new NameTy(currLineno(), currColno(), sym(typename)), d.intValue()); :}
  ;

dims ::= LBRACKET RBRACKET {: RESULT = new Integer(1); :}
  | LBRACKET RBRACKET dims : d {: RESULT = new Integer(d.intValue() + 1); :}
  ;

map_type ::= MAP LT type:t1 COMMA type:t2 GT
    {: RESULT = new MapTy(currLineno(), currColno(), t1, t2); :}
  ;

/* A possibly empty list of IDs denoting type names. */
// Currently commented this code out since it isn't being
// used anywhere else in this cup file and cup is giving
// warnings. Uncomment once these rules are used elsewhere.
//   
//opt_parenthesized_type_lst ::= /* EMPTY */
//	    {: RESULT = null; :}
//	    | LPAREN RPAREN
//	    {: RESULT = null; :}
//	    | LPAREN type_lst:tl RPAREN
//	    {: RESULT = tl; :}
//	    ;

//type_lst ::= type:ty COMMA type_lst:tl
//	  {: RESULT = new FieldList(null, ty, tl); :}
//	| type:ty
//	  {: RESULT = new FieldList(null, ty, null); :}
//	;

/* Represents a list of IDs denoting type names. */
opt_parenthesized_type_var_lst ::= /* EMPTY */
    {: RESULT = null; :}
  | LPAREN RPAREN
    {: RESULT = null; :}
  | LPAREN type_var_lst:tl RPAREN
    {: RESULT = tl; :}
  ;

type_var_lst ::= type:ty ID:id COMMA type_var_lst:tl
    {: RESULT = new FieldList(sym(id), ty, tl); :}
  | type:ty ID:id
    {: RESULT = new FieldList(sym(id), ty, null); :}
  ;


/* A nonrandom function declaration may declare a nonrandom constant or
 * a non-random function.  The distinction is whether there is a
 * parenthesized list of arguments after the function/constant name.
 */
fixed_func_decl ::=
    FIXED type:ret_type ID:fname opt_parenthesized_type_var_lst:otl
    EQ expression:ex SEMI
    {: RESULT = new FixedFuncDec(currLineno(), currColno(), sym(fname), otl, ret_type, ex); :}
  ;

/**
 * random function declaration
 * including dependency statement
 */
rand_func_decl ::=
    RANDOM type:ret_type ID:fname opt_parenthesized_type_var_lst:otl
    dependency_statement_body:body SEMI
    {: RESULT = new RandomFuncDec(currLineno(), currColno(), sym(fname), otl, ret_type, body); :}
  ;

/**
 * number statement
 */
number_stmt ::=
    NUMSIGN name_type:ty opt_parenthesized_origin_var_list:otl
	dependency_statement_body:body SEMI
    {: RESULT = new NumberDec(currLineno(), currColno(), ty, otl, body); :}
  ;

opt_parenthesized_origin_var_list ::= LPAREN origin_var_list:e RPAREN
    {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

origin_var_list ::= ID:func EQ ID:var COMMA origin_var_list:n
    {: RESULT = new OriginFieldList(currLineno(), currColno(), sym(func), sym(var), n); :}
  | ID:func EQ ID:var
    {: RESULT = new OriginFieldList(currLineno(), currColno(), sym(func), sym(var), null); :}
  ;

/**
 * origin function declaration
 */
origin_func_decl ::=
    ORIGIN type:ret_type ID:fname LPAREN type:arg_type RPAREN SEMI
    {: RESULT = new OriginFuncDec(currLineno(), currColno(), sym(fname),
      new FieldList(null, arg_type, null), ret_type); :}
  ;

/**
 * declaration of distinct symbols, (guaranteed objects)
 */
distinct_decl ::=
    DISTINCT name_type:ty id_or_subid_list:e SEMI
    {: RESULT = new DistinctSymbolDec(currLineno(), currColno(), ty, e); :}
  ;

id_or_subid_list ::= id_or_subid:e {: RESULT = new SymbolArrayList(e, null); :}
  | id_or_subid:e COMMA id_or_subid_list:n
    {: RESULT = new SymbolArrayList(e, n); :}
  ;

id_or_subid ::= ID:id
    {: RESULT = new SymbolArray(currLineno(), currColno(), sym(id)); :}
  | ID:id LBRACKET INT_LITERAL:s RBRACKET
    {: RESULT = new SymbolArray(currLineno(), currColno(), sym(id), s.intValue()); :}
  ;

/**
 * declaration of a distribution
 */
distribution_decl ::=
    DISTRIBUTION ID:id EQ class_name:name
    LPAREN opt_expression_list:e RPAREN SEMI
    {: RESULT = new DistributionDec(currLineno(), currColno(), sym(id),
      new ClassName(currLineno(), currColno(), sym(name)), e); :}
  ;


/* reference to function name or Java class */
class_name ::= ID:id {: RESULT = id; :}
  | ID:id DOT class_name:n {: RESULT = id + "." + n; :}
  ;

/**
 * body of random function or number statement
 */
dependency_statement_body ::= EQ expression:e
    {: RESULT = e; :}
  | distribution_expr:e
    {: RESULT = e; :}
  | IF:a expression:e1 THEN dependency_statement_body:e2 elseif_list:e3
    {: RESULT = new IfExpr(currLineno(), currColno(), e1, e2, e3); :}
  | /* not recommended to add {}, just for compactibility of old syntax */
    LBRACE dependency_statement_body:e RBRACE
    {: RESULT = e; :}
  | IF:a expression:e1 dependency_statement_body:e2 elseif_list:e3
    {: error("missing THEN in dependency statement clause, proceed anyway");
    RESULT = new IfExpr(currLineno(), currColno(), e1, e2, e3); :}
//  | error
//    {: error("invalid body of random function or number statement"); :}
  ;

elseif_list ::=
//    ELSEIF:eif expression:e1 THEN dependency_statement_body:e2 elseif_list:e3
//    {: RESULT = new IfExpr(eifleft, e1, e2, e3); :} |
    ELSE dependency_statement_body:e
    {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

parameter_decl ::= PARAM type:ty ID:id SEMI
    {: RESULT = new ParameterDec(currLineno(), currColno(), ty, sym(id), null); :}
  | PARAM type:ty ID:id COLON expression:e SEMI
    {: RESULT = new ParameterDec(currLineno(), currColno(), ty, sym(id), e); :}
  ;

/* Represents a term, which can be either a 0-ary function application, a
 * variable, a  non-0-ary function application, or a built-in constant.
 * (Propagates an error-check from production for specific kinds of terms.)
 *
 * Result is null if the term is invalid.
 */

expression ::= operation_expr:e  {: RESULT = e; :}
  | distribution_expr:e {: RESULT = e; :}
  | literal:e  {: RESULT = e; :}
  | function_call:e {: RESULT = e; :}
  | list_construct_expression:e {: RESULT = e; :}
  | map_construct_expression:e {: RESULT = e; :}
  | quantified_formula:e {: RESULT = e; :}
  | set_expr:e {: RESULT = e; :}
  | number_expr:e {: RESULT = e; :}
  | symbol_expr:e {: RESULT = e; :}
  ;

literal ::= STRING_LITERAL:e
    {: RESULT = new StringExpr(currLineno(), currColno(), e.intern()); :}
  | CHAR_LITERAL:e
    {: RESULT = new StringExpr(currLineno(), currColno(), e.toString().intern()); :}
  | INT_LITERAL:e
    {: RESULT = new IntExpr(currLineno(), currColno(), e.intValue()); :}
  | DOUBLE_LITERAL:e
    {: RESULT = new DoubleExpr(currLineno(), currColno(), e.doubleValue()); :}
//  | TIME_LITERAL:e
//    {: RESULT = new TimeExpr(currLineno(), currColno(), e.intValue()); :}
  | BOOLEAN_LITERAL:e
    {: RESULT = new BooleanExpr(currLineno(), currColno(), e.booleanValue()); :}
  | NULL:e
    {: RESULT = new NullExpr(currLineno(), currColno()); :}
  ;

operation_expr ::= expression:e1 PLUS expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.PLUS, e2); :}
  | expression:e1 MINUS expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.MINUS, e2); :}
  | expression:e1 MULT expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.MULT, e2); :}
  | expression:e1 DIV expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.DIV, e2); :}
  | expression:e1 MOD expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.MOD, e2); :}
  | expression:e1 POWER expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.POWER, e2); :}
  | expression:e1 LT expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.LT, e2); :}
  | expression:e1 GT expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.GT, e2); :}
  | expression:e1 LEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.LEQ, e2); :}
  | expression:e1 GEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.GEQ, e2); :}
  | expression:e1 EQEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.EQ, e2); :}
  | expression:e1 NEQ expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.NEQ, e2); :}
  | expression:e1 AND expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.AND, e2); :}
  | expression:e1 OR expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.OR, e2); :}
  | expression:e1 DOUBLERIGHTARROW expression:e2
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.IMPLY, e2); :}
  | expression:e1 LBRACKET expression:e2 RBRACKET
    {: RESULT = new OpExpr(currLineno(), currColno(), e1, OpExpr.SUB, e2); :}
  | unary_operation_expr:e {: RESULT = e; :}
  ;

unary_operation_expr ::=
    MINUS expression:e
    {: RESULT = new OpExpr(currLineno(), currColno(), new IntExpr(currLineno(), currColno(), 0), OpExpr.NOT, e); :}
  | NOT expression:e
    {: RESULT = new OpExpr(currLineno(), currColno(), null, OpExpr.NOT, e); :}
  | AT:a expression:e
    {: RESULT = new OpExpr(currLineno(), currColno(), null, OpExpr.AT, e); :}
  | LPAREN expression:e RPAREN
    {: RESULT = e; :}
  ;


quantified_formula ::= FORALL type:ty ID:id expression:e
    {: RESULT = new QuantifiedFormulaExpr(currLineno(), currColno(),
    QuantifiedFormulaExpr.FORALL, ty, sym(id), e); :}
  | EXISTS type:ty ID:id expression:e
    {: RESULT = new QuantifiedFormulaExpr(currLineno(), currColno(),
    QuantifiedFormulaExpr.EXISTS, ty, sym(id), e); :}
  ;

function_call ::= class_name:id LPAREN opt_expression_list:e RPAREN
    {: RESULT = new FuncCallExpr(currLineno(), currColno(), sym(id), e); :}
  ;

symbol_expr ::= ID:id
    {: RESULT = new SymbolExpr(currLineno(), currColno(), sym(id)); :}
  ;

distribution_expr ::= DISTRIB class_name:name LPAREN opt_expression_list:e RPAREN
    {: RESULT = new DistributionExpr(currLineno(), currColno(), sym(name), e); :}
  ;

opt_expression_list ::= expression_list:e {: RESULT = e; :}
  | {: RESULT = null; :}
  ;

expression_list ::= expression:e COMMA expression_list:elst
    {: RESULT = new ExprList(e, elst); :}
  | expression:e
    {: RESULT = new ExprList(e, null); :}
  ;

list_construct_expression ::= LBRACKET opt_expression_list:e RBRACKET
    {: RESULT = new ListInitExpr(currLineno(), currColno(), e); :}
  | LBRACKET semi_colon_separated_expression_list:e RBRACKET
    {: RESULT = new ListInitExpr(currLineno(), currColno(), e); :}
  ;

semi_colon_separated_expression_list ::=
    expression_list:e SEMI semi_colon_separated_expression_list:elst
    {: RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), elst); :}
  | expression_list:e SEMI expression_list:e2
    {: RESULT = new ExprList(new ListInitExpr(currLineno(), currColno(), e), new ExprList(new ListInitExpr(e2left, e2), null)); :}
  ;

map_construct_expression ::= LBRACE expression_pair_list:e RBRACE
    {: RESULT = new MapInitExpr(currLineno(), currColno(), e); :}
  ;

// to avoid conflict with Imply expression
expression_pair_list ::=
    expression:e1 RIGHTARROW expression:e2 COMMA expression_pair_list:e3
    {: RESULT = new ExprTupleList(e1, e2, e3); :}
  | expression:e1 RIGHTARROW expression:e2 
    {: RESULT = new ExprTupleList(e1, e2, null); :}
  ;
  
number_expr ::= NUMSIGN set_expr:e
    {: RESULT = new NumberExpr(currLineno(), currColno(), e); :}
  | NUMSIGN type:ty
    {: RESULT = new NumberExpr(currLineno(), currColno(), new ImplicitSetExpr(currLineno(), currColno(), ty, null, null)); :}
  | NUMSIGN error
    {: error("expecting number expresssion here. # should be followed by a type or a set"); :}
  ;


set_expr ::= explicit_set:e {: RESULT = e; :}
  | implicit_set:e {: RESULT = e; :}
  | tuple_set:e {: RESULT = e; :}
  ;

explicit_set ::= LBRACE opt_expression_list:e RBRACE
    {: RESULT = new ExplicitSetExpr(currLineno(), currColno(), e); :}
  ;

implicit_set ::= LBRACE type:ty ID:id COLON expression:e RBRACE
    {: RESULT = new ImplicitSetExpr(currLineno(), currColno(), ty, sym(id), e); :}
  | LBRACE type:ty ID:id RBRACE
    {: RESULT = new ImplicitSetExpr(currLineno(), currColno(), ty, sym(id), null); :}
  ;

tuple_set ::= LBRACE expression_list:elst FOR type_var_lst:vars COLON expression:e RBRACE
    {: RESULT = new TupleSetExpr(currLineno(), currColno(), elst, vars, e); :}
  | LBRACE expression_list:elst FOR type_var_lst:vars RBRACE
    {: RESULT = new TupleSetExpr(currLineno(), currColno(), elst, vars, null); :}
  ;

///no implementation for PARFACTOR


/* Represents an evidence statement, which can be:
 *
 *    * a symbol evidence statement, listing observed objects of the specified
 *	  type subject to certain constraints
 *        (Semantic checks:
 *	      - whether the type for which the evidence is presented has been
 *		  declared;
 *	      - whether the formula is valid (error-check is propagated from
 *		  the productions for various kinds of formulas).);
 *    * a value evidence statement, stating the value of the specified
 *	  function on the specified tuple of arguments
 *        (Semantic checks:
 *	      - whether the numbers of the function's parameters and arguments
 *		  passed to it match;
 *            - whether the function has been declared.).
 */
evidence_stmt ::= OBS evidence:e SEMI {: RESULT = e; :}
  ;

evidence ::=
   symbol_evidence:e {: RESULT = e; :}
   | value_evidence:e {: RESULT = e; :}
//  | tuple_evidence:e {: RESULT = e; :} //not implemented yet
  ;

/* valid evidence format include (will be checked in semantic checking)
 *   - general form: random expression = fixed expression
 *   - symbol evidence: implicit_set = explicit_set of ids
 *   - number_evidence: # implicit_set = int constant
 */
value_evidence ::=
    expression:e1 EQ expression:e2
    {: RESULT = new ValueEvidence(currLineno(), currColno(), e1, e2); :}
  ;

symbol_evidence ::=
    implicit_set:e1 EQ explicit_set:e2
    {: RESULT = new SymbolEvidence(currLineno(), currColno(), e1, e2); :}
  ;

query_stmt ::= QUERY  query:q SEMI
    {: RESULT = q; :}
  ;

query ::= expression:e {: RESULT = new QueryStmt(currLineno(), currColno(), e); :}
  ;
